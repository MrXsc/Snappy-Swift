// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: KNCommandArchives.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum KN_AnimationReferent: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case kRelativeToStart // = 1
  case kRelativeToEnd // = 2

  init() {
    self = .kRelativeToStart
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .kRelativeToStart
    case 2: self = .kRelativeToEnd
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .kRelativeToStart: return 1
    case .kRelativeToEnd: return 2
    }
  }

}

#if swift(>=4.2)

extension KN_AnimationReferent: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct KN_UIStateCommandGroupArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandGroupArchive {
    get {return _super ?? TSK_CommandGroupArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var uiState: TSP_Reference {
    get {return _uiState ?? TSP_Reference()}
    set {_uiState = newValue}
  }
  /// Returns true if `uiState` has been explicitly set.
  var hasUiState: Bool {return self._uiState != nil}
  /// Clears the value of `uiState`. Subsequent reads from it will return its default value.
  mutating func clearUiState() {self._uiState = nil}

  var property: String {
    get {return _property ?? String()}
    set {_property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return self._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {self._property = nil}

  var slideNodesToEdit: [TSP_Reference] = []

  var masterSlideNodesToApply: [TSP_Reference] = []

  var thumbnailSizes: [TSP_Size] = []

  var selectedSlideNodes: [TSP_Reference] = []

  var restoreSelectedSlideNodes: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandGroupArchive? = nil
  fileprivate var _uiState: TSP_Reference? = nil
  fileprivate var _property: String? = nil
}

struct KN_CommandSlideInsertDrawablesArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var slideID: TSP_UUID {
    get {return _storage._slideID ?? TSP_UUID()}
    set {_uniqueStorage()._slideID = newValue}
  }
  /// Returns true if `slideID` has been explicitly set.
  var hasSlideID: Bool {return _storage._slideID != nil}
  /// Clears the value of `slideID`. Subsequent reads from it will return its default value.
  mutating func clearSlideID() {_uniqueStorage()._slideID = nil}

  var drawables: [TSP_Reference] {
    get {return _storage._drawables}
    set {_uniqueStorage()._drawables = newValue}
  }

  var workingDrawables: [TSP_Reference] {
    get {return _storage._workingDrawables}
    set {_uniqueStorage()._workingDrawables = newValue}
  }

  var argsList: KN_MixedIdOperationArgs {
    get {return _storage._argsList ?? KN_MixedIdOperationArgs()}
    set {_uniqueStorage()._argsList = newValue}
  }
  /// Returns true if `argsList` has been explicitly set.
  var hasArgsList: Bool {return _storage._argsList != nil}
  /// Clears the value of `argsList`. Subsequent reads from it will return its default value.
  mutating func clearArgsList() {_uniqueStorage()._argsList = nil}

  var updateGeometryToMatchObjectPlaceholder: Bool {
    get {return _storage._updateGeometryToMatchObjectPlaceholder ?? false}
    set {_uniqueStorage()._updateGeometryToMatchObjectPlaceholder = newValue}
  }
  /// Returns true if `updateGeometryToMatchObjectPlaceholder` has been explicitly set.
  var hasUpdateGeometryToMatchObjectPlaceholder: Bool {return _storage._updateGeometryToMatchObjectPlaceholder != nil}
  /// Clears the value of `updateGeometryToMatchObjectPlaceholder`. Subsequent reads from it will return its default value.
  mutating func clearUpdateGeometryToMatchObjectPlaceholder() {_uniqueStorage()._updateGeometryToMatchObjectPlaceholder = nil}

  var idsOfDrawablesUsingObjectPlaceholderGeometry: [TSP_UUID] {
    get {return _storage._idsOfDrawablesUsingObjectPlaceholderGeometry}
    set {_uniqueStorage()._idsOfDrawablesUsingObjectPlaceholderGeometry = newValue}
  }

  var sagePlaceholderTagsList: [String] {
    get {return _storage._sagePlaceholderTagsList}
    set {_uniqueStorage()._sagePlaceholderTagsList = newValue}
  }

  var instructionalTextList: [String] {
    get {return _storage._instructionalTextList}
    set {_uniqueStorage()._instructionalTextList = newValue}
  }

  var undoArchive: TSP_Reference {
    get {return _storage._undoArchive ?? TSP_Reference()}
    set {_uniqueStorage()._undoArchive = newValue}
  }
  /// Returns true if `undoArchive` has been explicitly set.
  var hasUndoArchive: Bool {return _storage._undoArchive != nil}
  /// Clears the value of `undoArchive`. Subsequent reads from it will return its default value.
  mutating func clearUndoArchive() {_uniqueStorage()._undoArchive = nil}

  var isPasting: Bool {
    get {return _storage._isPasting ?? false}
    set {_uniqueStorage()._isPasting = newValue}
  }
  /// Returns true if `isPasting` has been explicitly set.
  var hasIsPasting: Bool {return _storage._isPasting != nil}
  /// Clears the value of `isPasting`. Subsequent reads from it will return its default value.
  mutating func clearIsPasting() {_uniqueStorage()._isPasting = nil}

  var insertBuildDescriptions: [TSP_Reference] {
    get {return _storage._insertBuildDescriptions}
    set {_uniqueStorage()._insertBuildDescriptions = newValue}
  }

  var workingInsertBuildDescriptions: [TSP_Reference] {
    get {return _storage._workingInsertBuildDescriptions}
    set {_uniqueStorage()._workingInsertBuildDescriptions = newValue}
  }

  var removeBuildDescriptions: [TSP_Reference] {
    get {return _storage._removeBuildDescriptions}
    set {_uniqueStorage()._removeBuildDescriptions = newValue}
  }

  var removeSlideSpecificHyperlinks: Bool {
    get {return _storage._removeSlideSpecificHyperlinks ?? false}
    set {_uniqueStorage()._removeSlideSpecificHyperlinks = newValue}
  }
  /// Returns true if `removeSlideSpecificHyperlinks` has been explicitly set.
  var hasRemoveSlideSpecificHyperlinks: Bool {return _storage._removeSlideSpecificHyperlinks != nil}
  /// Clears the value of `removeSlideSpecificHyperlinks`. Subsequent reads from it will return its default value.
  mutating func clearRemoveSlideSpecificHyperlinks() {_uniqueStorage()._removeSlideSpecificHyperlinks = nil}

  var customFormatKeys: [TSP_UUID] {
    get {return _storage._customFormatKeys}
    set {_uniqueStorage()._customFormatKeys = newValue}
  }

  var savedNextUntitledResolverIndex: UInt32 {
    get {return _storage._savedNextUntitledResolverIndex ?? 0}
    set {_uniqueStorage()._savedNextUntitledResolverIndex = newValue}
  }
  /// Returns true if `savedNextUntitledResolverIndex` has been explicitly set.
  var hasSavedNextUntitledResolverIndex: Bool {return _storage._savedNextUntitledResolverIndex != nil}
  /// Clears the value of `savedNextUntitledResolverIndex`. Subsequent reads from it will return its default value.
  mutating func clearSavedNextUntitledResolverIndex() {_uniqueStorage()._savedNextUntitledResolverIndex = nil}

  var geometryOfObjectPlaceholderForComparisonToRestoreLink: TSD_GeometryArchive {
    get {return _storage._geometryOfObjectPlaceholderForComparisonToRestoreLink ?? TSD_GeometryArchive()}
    set {_uniqueStorage()._geometryOfObjectPlaceholderForComparisonToRestoreLink = newValue}
  }
  /// Returns true if `geometryOfObjectPlaceholderForComparisonToRestoreLink` has been explicitly set.
  var hasGeometryOfObjectPlaceholderForComparisonToRestoreLink: Bool {return _storage._geometryOfObjectPlaceholderForComparisonToRestoreLink != nil}
  /// Clears the value of `geometryOfObjectPlaceholderForComparisonToRestoreLink`. Subsequent reads from it will return its default value.
  mutating func clearGeometryOfObjectPlaceholderForComparisonToRestoreLink() {_uniqueStorage()._geometryOfObjectPlaceholderForComparisonToRestoreLink = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandSlideSetPlaceholdersForTagsArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideID: TSP_UUID {
    get {return _slideID ?? TSP_UUID()}
    set {_slideID = newValue}
  }
  /// Returns true if `slideID` has been explicitly set.
  var hasSlideID: Bool {return self._slideID != nil}
  /// Clears the value of `slideID`. Subsequent reads from it will return its default value.
  mutating func clearSlideID() {self._slideID = nil}

  var infos: [TSP_Reference] = []

  var tags: [String] = []

  var oldInfos: [TSP_Reference] = []

  var oldTags: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideID: TSP_UUID? = nil
}

struct KN_CommandMasterSlideSetPlaceholderForTagArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: KN_CommandSlideSetPlaceholdersForTagsArchive {
    get {return _super ?? KN_CommandSlideSetPlaceholdersForTagsArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var placeholderID: TSP_UUID {
    get {return _placeholderID ?? TSP_UUID()}
    set {_placeholderID = newValue}
  }
  /// Returns true if `placeholderID` has been explicitly set.
  var hasPlaceholderID: Bool {return self._placeholderID != nil}
  /// Clears the value of `placeholderID`. Subsequent reads from it will return its default value.
  mutating func clearPlaceholderID() {self._placeholderID = nil}

  var tag: String {
    get {return _tag ?? String()}
    set {_tag = newValue}
  }
  /// Returns true if `tag` has been explicitly set.
  var hasTag: Bool {return self._tag != nil}
  /// Clears the value of `tag`. Subsequent reads from it will return its default value.
  mutating func clearTag() {self._tag = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: KN_CommandSlideSetPlaceholdersForTagsArchive? = nil
  fileprivate var _placeholderID: TSP_UUID? = nil
  fileprivate var _tag: String? = nil
}

struct KN_CommandSlidePropagateSetPlaceholderForTagArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: KN_CommandSlideSetPlaceholdersForTagsArchive {
    get {return _super ?? KN_CommandSlideSetPlaceholdersForTagsArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var placeholderID: TSP_UUID {
    get {return _placeholderID ?? TSP_UUID()}
    set {_placeholderID = newValue}
  }
  /// Returns true if `placeholderID` has been explicitly set.
  var hasPlaceholderID: Bool {return self._placeholderID != nil}
  /// Clears the value of `placeholderID`. Subsequent reads from it will return its default value.
  mutating func clearPlaceholderID() {self._placeholderID = nil}

  var originalID: TSP_UUID {
    get {return _originalID ?? TSP_UUID()}
    set {_originalID = newValue}
  }
  /// Returns true if `originalID` has been explicitly set.
  var hasOriginalID: Bool {return self._originalID != nil}
  /// Clears the value of `originalID`. Subsequent reads from it will return its default value.
  mutating func clearOriginalID() {self._originalID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: KN_CommandSlideSetPlaceholdersForTagsArchive? = nil
  fileprivate var _placeholderID: TSP_UUID? = nil
  fileprivate var _originalID: TSP_UUID? = nil
}

struct KN_CommandSlideRemoveDrawableArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideID: TSP_UUID {
    get {return _slideID ?? TSP_UUID()}
    set {_slideID = newValue}
  }
  /// Returns true if `slideID` has been explicitly set.
  var hasSlideID: Bool {return self._slideID != nil}
  /// Clears the value of `slideID`. Subsequent reads from it will return its default value.
  mutating func clearSlideID() {self._slideID = nil}

  var sortedDrawables: [TSP_Reference] = []

  var argsList: KN_MixedIdOperationArgs {
    get {return _argsList ?? KN_MixedIdOperationArgs()}
    set {_argsList = newValue}
  }
  /// Returns true if `argsList` has been explicitly set.
  var hasArgsList: Bool {return self._argsList != nil}
  /// Clears the value of `argsList`. Subsequent reads from it will return its default value.
  mutating func clearArgsList() {self._argsList = nil}

  var drawableIndexesForUndo: [UInt32] = []

  var placeholderTags: [String] = []

  var instructionalTextList: [String] = []

  var insertBuildDescriptions: [TSP_Reference] = []

  var removeBuildDescriptions: [TSP_Reference] = []

  var drawablesUsingObjectPlaceholderGeometry: [TSP_Reference] = []

  var inverseInsertHyperlinkCommands: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideID: TSP_UUID? = nil
  fileprivate var _argsList: KN_MixedIdOperationArgs? = nil
}

struct KN_CommandSlideMoveDrawableZOrderArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var oldOrderedInfos: [TSP_Reference] = []

  var argsList: [TSK_RearrangeIdOperationArgs] = []

  var slideID: TSP_UUID {
    get {return _slideID ?? TSP_UUID()}
    set {_slideID = newValue}
  }
  /// Returns true if `slideID` has been explicitly set.
  var hasSlideID: Bool {return self._slideID != nil}
  /// Clears the value of `slideID`. Subsequent reads from it will return its default value.
  mutating func clearSlideID() {self._slideID = nil}

  var oldOrderedInfosOnSlideForUndo: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideID: TSP_UUID? = nil
}

struct KN_CommandSlideNodeSetPropertyArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideNodeIDPath: TSP_UUIDPath {
    get {return _slideNodeIDPath ?? TSP_UUIDPath()}
    set {_slideNodeIDPath = newValue}
  }
  /// Returns true if `slideNodeIDPath` has been explicitly set.
  var hasSlideNodeIDPath: Bool {return self._slideNodeIDPath != nil}
  /// Clears the value of `slideNodeIDPath`. Subsequent reads from it will return its default value.
  mutating func clearSlideNodeIDPath() {self._slideNodeIDPath = nil}

  var property: String {
    get {return _property ?? String()}
    set {_property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return self._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {self._property = nil}

  var oldValue: Bool {
    get {return _oldValue ?? false}
    set {_oldValue = newValue}
  }
  /// Returns true if `oldValue` has been explicitly set.
  var hasOldValue: Bool {return self._oldValue != nil}
  /// Clears the value of `oldValue`. Subsequent reads from it will return its default value.
  mutating func clearOldValue() {self._oldValue = nil}

  var value: Bool {
    get {return _value ?? false}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideNodeIDPath: TSP_UUIDPath? = nil
  fileprivate var _property: String? = nil
  fileprivate var _oldValue: Bool? = nil
  fileprivate var _value: Bool? = nil
}

struct KN_CommandSlideNodeSetViewStatePropertyArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideNodeIDPath: TSP_UUIDPath {
    get {return _slideNodeIDPath ?? TSP_UUIDPath()}
    set {_slideNodeIDPath = newValue}
  }
  /// Returns true if `slideNodeIDPath` has been explicitly set.
  var hasSlideNodeIDPath: Bool {return self._slideNodeIDPath != nil}
  /// Clears the value of `slideNodeIDPath`. Subsequent reads from it will return its default value.
  mutating func clearSlideNodeIDPath() {self._slideNodeIDPath = nil}

  var property: String {
    get {return _property ?? String()}
    set {_property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return self._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {self._property = nil}

  var oldValue: Bool {
    get {return _oldValue ?? false}
    set {_oldValue = newValue}
  }
  /// Returns true if `oldValue` has been explicitly set.
  var hasOldValue: Bool {return self._oldValue != nil}
  /// Clears the value of `oldValue`. Subsequent reads from it will return its default value.
  mutating func clearOldValue() {self._oldValue = nil}

  var value: Bool {
    get {return _value ?? false}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideNodeIDPath: TSP_UUIDPath? = nil
  fileprivate var _property: String? = nil
  fileprivate var _oldValue: Bool? = nil
  fileprivate var _value: Bool? = nil
}

struct KN_CommandSlideSetBackgroundFillArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideIDPath: TSP_UUIDPath {
    get {return _slideIDPath ?? TSP_UUIDPath()}
    set {_slideIDPath = newValue}
  }
  /// Returns true if `slideIDPath` has been explicitly set.
  var hasSlideIDPath: Bool {return self._slideIDPath != nil}
  /// Clears the value of `slideIDPath`. Subsequent reads from it will return its default value.
  mutating func clearSlideIDPath() {self._slideIDPath = nil}

  var oldFill: TSD_FillArchive {
    get {return _oldFill ?? TSD_FillArchive()}
    set {_oldFill = newValue}
  }
  /// Returns true if `oldFill` has been explicitly set.
  var hasOldFill: Bool {return self._oldFill != nil}
  /// Clears the value of `oldFill`. Subsequent reads from it will return its default value.
  mutating func clearOldFill() {self._oldFill = nil}

  var newFill: TSD_FillArchive {
    get {return _newFill ?? TSD_FillArchive()}
    set {_newFill = newValue}
  }
  /// Returns true if `newFill` has been explicitly set.
  var hasNewFill: Bool {return self._newFill != nil}
  /// Clears the value of `newFill`. Subsequent reads from it will return its default value.
  mutating func clearNewFill() {self._newFill = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideIDPath: TSP_UUIDPath? = nil
  fileprivate var _oldFill: TSD_FillArchive? = nil
  fileprivate var _newFill: TSD_FillArchive? = nil
}

struct KN_CommandSlideSetStyleArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideIDPath: TSP_UUIDPath {
    get {return _slideIDPath ?? TSP_UUIDPath()}
    set {_slideIDPath = newValue}
  }
  /// Returns true if `slideIDPath` has been explicitly set.
  var hasSlideIDPath: Bool {return self._slideIDPath != nil}
  /// Clears the value of `slideIDPath`. Subsequent reads from it will return its default value.
  mutating func clearSlideIDPath() {self._slideIDPath = nil}

  var slideStyle: TSP_Reference {
    get {return _slideStyle ?? TSP_Reference()}
    set {_slideStyle = newValue}
  }
  /// Returns true if `slideStyle` has been explicitly set.
  var hasSlideStyle: Bool {return self._slideStyle != nil}
  /// Clears the value of `slideStyle`. Subsequent reads from it will return its default value.
  mutating func clearSlideStyle() {self._slideStyle = nil}

  var oldSlideStyle: TSP_Reference {
    get {return _oldSlideStyle ?? TSP_Reference()}
    set {_oldSlideStyle = newValue}
  }
  /// Returns true if `oldSlideStyle` has been explicitly set.
  var hasOldSlideStyle: Bool {return self._oldSlideStyle != nil}
  /// Clears the value of `oldSlideStyle`. Subsequent reads from it will return its default value.
  mutating func clearOldSlideStyle() {self._oldSlideStyle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideIDPath: TSP_UUIDPath? = nil
  fileprivate var _slideStyle: TSP_Reference? = nil
  fileprivate var _oldSlideStyle: TSP_Reference? = nil
}

struct KN_CommandShowMarkOutOfSyncRecordingArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var show: TSP_Reference {
    get {return _show ?? TSP_Reference()}
    set {_show = newValue}
  }
  /// Returns true if `show` has been explicitly set.
  var hasShow: Bool {return self._show != nil}
  /// Clears the value of `show`. Subsequent reads from it will return its default value.
  mutating func clearShow() {self._show = nil}

  var oldRecording: TSP_Reference {
    get {return _oldRecording ?? TSP_Reference()}
    set {_oldRecording = newValue}
  }
  /// Returns true if `oldRecording` has been explicitly set.
  var hasOldRecording: Bool {return self._oldRecording != nil}
  /// Clears the value of `oldRecording`. Subsequent reads from it will return its default value.
  mutating func clearOldRecording() {self._oldRecording = nil}

  var oldIsRecordingOutOfSync: Bool {
    get {return _oldIsRecordingOutOfSync ?? false}
    set {_oldIsRecordingOutOfSync = newValue}
  }
  /// Returns true if `oldIsRecordingOutOfSync` has been explicitly set.
  var hasOldIsRecordingOutOfSync: Bool {return self._oldIsRecordingOutOfSync != nil}
  /// Clears the value of `oldIsRecordingOutOfSync`. Subsequent reads from it will return its default value.
  mutating func clearOldIsRecordingOutOfSync() {self._oldIsRecordingOutOfSync = nil}

  var newIsRecordingOutOfSync: Bool {
    get {return _newIsRecordingOutOfSync ?? false}
    set {_newIsRecordingOutOfSync = newValue}
  }
  /// Returns true if `newIsRecordingOutOfSync` has been explicitly set.
  var hasNewIsRecordingOutOfSync: Bool {return self._newIsRecordingOutOfSync != nil}
  /// Clears the value of `newIsRecordingOutOfSync`. Subsequent reads from it will return its default value.
  mutating func clearNewIsRecordingOutOfSync() {self._newIsRecordingOutOfSync = nil}

  var oldModificationDate: TSP_Date {
    get {return _oldModificationDate ?? TSP_Date()}
    set {_oldModificationDate = newValue}
  }
  /// Returns true if `oldModificationDate` has been explicitly set.
  var hasOldModificationDate: Bool {return self._oldModificationDate != nil}
  /// Clears the value of `oldModificationDate`. Subsequent reads from it will return its default value.
  mutating func clearOldModificationDate() {self._oldModificationDate = nil}

  var newModificationDate: TSP_Date {
    get {return _newModificationDate ?? TSP_Date()}
    set {_newModificationDate = newValue}
  }
  /// Returns true if `newModificationDate` has been explicitly set.
  var hasNewModificationDate: Bool {return self._newModificationDate != nil}
  /// Clears the value of `newModificationDate`. Subsequent reads from it will return its default value.
  mutating func clearNewModificationDate() {self._newModificationDate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _show: TSP_Reference? = nil
  fileprivate var _oldRecording: TSP_Reference? = nil
  fileprivate var _oldIsRecordingOutOfSync: Bool? = nil
  fileprivate var _newIsRecordingOutOfSync: Bool? = nil
  fileprivate var _oldModificationDate: TSP_Date? = nil
  fileprivate var _newModificationDate: TSP_Date? = nil
}

struct KN_CommandShowMarkOutOfSyncRecordingIfNeededArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var outOfSyncToken: TSP_UUID {
    get {return _outOfSyncToken ?? TSP_UUID()}
    set {_outOfSyncToken = newValue}
  }
  /// Returns true if `outOfSyncToken` has been explicitly set.
  var hasOutOfSyncToken: Bool {return self._outOfSyncToken != nil}
  /// Clears the value of `outOfSyncToken`. Subsequent reads from it will return its default value.
  mutating func clearOutOfSyncToken() {self._outOfSyncToken = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _outOfSyncToken: TSP_UUID? = nil
}

struct KN_CommandShowRemoveRecordingArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var show: TSP_Reference {
    get {return _show ?? TSP_Reference()}
    set {_show = newValue}
  }
  /// Returns true if `show` has been explicitly set.
  var hasShow: Bool {return self._show != nil}
  /// Clears the value of `show`. Subsequent reads from it will return its default value.
  mutating func clearShow() {self._show = nil}

  var oldRecording: TSP_Reference {
    get {return _oldRecording ?? TSP_Reference()}
    set {_oldRecording = newValue}
  }
  /// Returns true if `oldRecording` has been explicitly set.
  var hasOldRecording: Bool {return self._oldRecording != nil}
  /// Clears the value of `oldRecording`. Subsequent reads from it will return its default value.
  mutating func clearOldRecording() {self._oldRecording = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _show: TSP_Reference? = nil
  fileprivate var _oldRecording: TSP_Reference? = nil
}

struct KN_CommandShowReplaceRecordingArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var show: TSP_Reference {
    get {return _show ?? TSP_Reference()}
    set {_show = newValue}
  }
  /// Returns true if `show` has been explicitly set.
  var hasShow: Bool {return self._show != nil}
  /// Clears the value of `show`. Subsequent reads from it will return its default value.
  mutating func clearShow() {self._show = nil}

  var replacementRecording: TSP_Reference {
    get {return _replacementRecording ?? TSP_Reference()}
    set {_replacementRecording = newValue}
  }
  /// Returns true if `replacementRecording` has been explicitly set.
  var hasReplacementRecording: Bool {return self._replacementRecording != nil}
  /// Clears the value of `replacementRecording`. Subsequent reads from it will return its default value.
  mutating func clearReplacementRecording() {self._replacementRecording = nil}

  var oldRecording: TSP_Reference {
    get {return _oldRecording ?? TSP_Reference()}
    set {_oldRecording = newValue}
  }
  /// Returns true if `oldRecording` has been explicitly set.
  var hasOldRecording: Bool {return self._oldRecording != nil}
  /// Clears the value of `oldRecording`. Subsequent reads from it will return its default value.
  mutating func clearOldRecording() {self._oldRecording = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _show: TSP_Reference? = nil
  fileprivate var _replacementRecording: TSP_Reference? = nil
  fileprivate var _oldRecording: TSP_Reference? = nil
}

struct KN_CommandShowSetValueArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var show: TSP_Reference {
    get {return _show ?? TSP_Reference()}
    set {_show = newValue}
  }
  /// Returns true if `show` has been explicitly set.
  var hasShow: Bool {return self._show != nil}
  /// Clears the value of `show`. Subsequent reads from it will return its default value.
  mutating func clearShow() {self._show = nil}

  var property: String {
    get {return _property ?? String()}
    set {_property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return self._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {self._property = nil}

  var oldValue: KN_CommandShowSetValueArchive.PropertyValue {
    get {return _oldValue ?? KN_CommandShowSetValueArchive.PropertyValue()}
    set {_oldValue = newValue}
  }
  /// Returns true if `oldValue` has been explicitly set.
  var hasOldValue: Bool {return self._oldValue != nil}
  /// Clears the value of `oldValue`. Subsequent reads from it will return its default value.
  mutating func clearOldValue() {self._oldValue = nil}

  var newValue: KN_CommandShowSetValueArchive.PropertyValue {
    get {return _newValue ?? KN_CommandShowSetValueArchive.PropertyValue()}
    set {_newValue = newValue}
  }
  /// Returns true if `newValue` has been explicitly set.
  var hasNewValue: Bool {return self._newValue != nil}
  /// Clears the value of `newValue`. Subsequent reads from it will return its default value.
  mutating func clearNewValue() {self._newValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PropertyValue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var boolValue: Bool {
      get {return _boolValue ?? false}
      set {_boolValue = newValue}
    }
    /// Returns true if `boolValue` has been explicitly set.
    var hasBoolValue: Bool {return self._boolValue != nil}
    /// Clears the value of `boolValue`. Subsequent reads from it will return its default value.
    mutating func clearBoolValue() {self._boolValue = nil}

    var doubleValue: Double {
      get {return _doubleValue ?? 0}
      set {_doubleValue = newValue}
    }
    /// Returns true if `doubleValue` has been explicitly set.
    var hasDoubleValue: Bool {return self._doubleValue != nil}
    /// Clears the value of `doubleValue`. Subsequent reads from it will return its default value.
    mutating func clearDoubleValue() {self._doubleValue = nil}

    var showModeValue: KN_ShowArchive.KNShowMode {
      get {return _showModeValue ?? .kKnshowModeNormal}
      set {_showModeValue = newValue}
    }
    /// Returns true if `showModeValue` has been explicitly set.
    var hasShowModeValue: Bool {return self._showModeValue != nil}
    /// Clears the value of `showModeValue`. Subsequent reads from it will return its default value.
    mutating func clearShowModeValue() {self._showModeValue = nil}

    var sizeValue: TSP_Size {
      get {return _sizeValue ?? TSP_Size()}
      set {_sizeValue = newValue}
    }
    /// Returns true if `sizeValue` has been explicitly set.
    var hasSizeValue: Bool {return self._sizeValue != nil}
    /// Clears the value of `sizeValue`. Subsequent reads from it will return its default value.
    mutating func clearSizeValue() {self._sizeValue = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _boolValue: Bool? = nil
    fileprivate var _doubleValue: Double? = nil
    fileprivate var _showModeValue: KN_ShowArchive.KNShowMode? = nil
    fileprivate var _sizeValue: TSP_Size? = nil
  }

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _show: TSP_Reference? = nil
  fileprivate var _property: String? = nil
  fileprivate var _oldValue: KN_CommandShowSetValueArchive.PropertyValue? = nil
  fileprivate var _newValue: KN_CommandShowSetValueArchive.PropertyValue? = nil
}

struct KN_CommandShowInsertSlideArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideNodesBeingInserted: [TSP_Reference] = []

  var workingSlideNodesBeingInserted: [TSP_Reference] = []

  var insertedArgsList: [TSK_AddIdOperationArgs] = []

  var idsOfSlideNodesWithDepthChanges: [TSP_UUID] = []

  var depthsOfSlideNodesWithDepthChanges: [UInt32] = []

  var oldDepthsOfSlideNodesWithDepthChanges: [UInt32] = []

  var slideNodesForDepthFixUp: [TSP_Reference] = []

  var depthsOfSlideNodesForDepthFixUp: [UInt32] = []

  var oldDepthsOfSlideNodesForDepthFixUp: [UInt32] = []

  var kind: KN_CommandShowInsertSlideArchive.Kind {
    get {return _kind ?? .kKindInsertSlide}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {self._kind = nil}

  var masterNodesBeingInserted: [TSP_Reference] = []

  var customFormatKeys: [TSP_UUID] = []

  var collapsedStateOfSlideNodesBeingInserted: [Bool] = []

  var undoArchive: TSP_Reference {
    get {return _undoArchive ?? TSP_Reference()}
    set {_undoArchive = newValue}
  }
  /// Returns true if `undoArchive` has been explicitly set.
  var hasUndoArchive: Bool {return self._undoArchive != nil}
  /// Clears the value of `undoArchive`. Subsequent reads from it will return its default value.
  mutating func clearUndoArchive() {self._undoArchive = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Kind: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case kKindInsertSlide // = 0
    case kKindInsertSlideForPaste // = 1
    case kKindInsertSlideForDuplicate // = 2

    init() {
      self = .kKindInsertSlide
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .kKindInsertSlide
      case 1: self = .kKindInsertSlideForPaste
      case 2: self = .kKindInsertSlideForDuplicate
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .kKindInsertSlide: return 0
      case .kKindInsertSlideForPaste: return 1
      case .kKindInsertSlideForDuplicate: return 2
      }
    }

  }

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _kind: KN_CommandShowInsertSlideArchive.Kind? = nil
  fileprivate var _undoArchive: TSP_Reference? = nil
}

#if swift(>=4.2)

extension KN_CommandShowInsertSlideArchive.Kind: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct KN_CommandShowMoveSlideArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideNodesBeingMovedLinearly: [TSP_Reference] = []

  var rearrangedArgsList: [TSK_RearrangeIdOperationArgs] = []

  var idsOfSlideNodesWithDepthChanges: [TSP_UUID] = []

  var depthsOfSlideNodesWithDepthChanges: [UInt32] = []

  var oldDepthsOfSlideNodesWithDepthChanges: [UInt32] = []

  var slideNodesForDepthFixUp: [TSP_Reference] = []

  var depthsOfSlideNodesForDepthFixUp: [UInt32] = []

  var oldDepthsOfSlideNodesForDepthFixUp: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
}

struct KN_CommandShowRemoveSlideArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideNodesBeingRemoved: [TSP_Reference] = []

  var removedArgsList: [TSK_RemoveIdOperationArgs] = []

  var idsOfSlideNodesWithDepthChanges: [TSP_UUID] = []

  var depthsOfSlideNodesWithDepthChanges: [UInt32] = []

  var oldDepthsOfSlideNodesWithDepthChanges: [UInt32] = []

  var slideNodesForDepthFixUp: [TSP_Reference] = []

  var depthsOfSlideNodesForDepthFixUp: [UInt32] = []

  var oldDepthsOfSlideNodesForDepthFixUp: [UInt32] = []

  var collapsedStateOfSlideNodesBeingRemoved: [Bool] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
}

struct KN_CommandShowChangeThemeArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var show: TSP_Reference {
    get {return _show ?? TSP_Reference()}
    set {_show = newValue}
  }
  /// Returns true if `show` has been explicitly set.
  var hasShow: Bool {return self._show != nil}
  /// Clears the value of `show`. Subsequent reads from it will return its default value.
  mutating func clearShow() {self._show = nil}

  var theme: TSP_Reference {
    get {return _theme ?? TSP_Reference()}
    set {_theme = newValue}
  }
  /// Returns true if `theme` has been explicitly set.
  var hasTheme: Bool {return self._theme != nil}
  /// Clears the value of `theme`. Subsequent reads from it will return its default value.
  mutating func clearTheme() {self._theme = nil}

  var oldTheme: TSP_Reference {
    get {return _oldTheme ?? TSP_Reference()}
    set {_oldTheme = newValue}
  }
  /// Returns true if `oldTheme` has been explicitly set.
  var hasOldTheme: Bool {return self._oldTheme != nil}
  /// Clears the value of `oldTheme`. Subsequent reads from it will return its default value.
  mutating func clearOldTheme() {self._oldTheme = nil}

  var templateIdentifier: String {
    get {return _templateIdentifier ?? String()}
    set {_templateIdentifier = newValue}
  }
  /// Returns true if `templateIdentifier` has been explicitly set.
  var hasTemplateIdentifier: Bool {return self._templateIdentifier != nil}
  /// Clears the value of `templateIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearTemplateIdentifier() {self._templateIdentifier = nil}

  var oldTemplateIdentifier: String {
    get {return _oldTemplateIdentifier ?? String()}
    set {_oldTemplateIdentifier = newValue}
  }
  /// Returns true if `oldTemplateIdentifier` has been explicitly set.
  var hasOldTemplateIdentifier: Bool {return self._oldTemplateIdentifier != nil}
  /// Clears the value of `oldTemplateIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearOldTemplateIdentifier() {self._oldTemplateIdentifier = nil}

  var identifierToStyleMap: KN_CommandShowChangeThemeArchive.IdentifierToStyleMap {
    get {return _identifierToStyleMap ?? KN_CommandShowChangeThemeArchive.IdentifierToStyleMap()}
    set {_identifierToStyleMap = newValue}
  }
  /// Returns true if `identifierToStyleMap` has been explicitly set.
  var hasIdentifierToStyleMap: Bool {return self._identifierToStyleMap != nil}
  /// Clears the value of `identifierToStyleMap`. Subsequent reads from it will return its default value.
  mutating func clearIdentifierToStyleMap() {self._identifierToStyleMap = nil}

  var oldIdentifierToStyleMap: KN_CommandShowChangeThemeArchive.IdentifierToStyleMap {
    get {return _oldIdentifierToStyleMap ?? KN_CommandShowChangeThemeArchive.IdentifierToStyleMap()}
    set {_oldIdentifierToStyleMap = newValue}
  }
  /// Returns true if `oldIdentifierToStyleMap` has been explicitly set.
  var hasOldIdentifierToStyleMap: Bool {return self._oldIdentifierToStyleMap != nil}
  /// Clears the value of `oldIdentifierToStyleMap`. Subsequent reads from it will return its default value.
  mutating func clearOldIdentifierToStyleMap() {self._oldIdentifierToStyleMap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct IdentifierToStyleMap {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var styles: [TSS_StylesheetArchive.IdentifiedStyleEntry] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _show: TSP_Reference? = nil
  fileprivate var _theme: TSP_Reference? = nil
  fileprivate var _oldTheme: TSP_Reference? = nil
  fileprivate var _templateIdentifier: String? = nil
  fileprivate var _oldTemplateIdentifier: String? = nil
  fileprivate var _identifierToStyleMap: KN_CommandShowChangeThemeArchive.IdentifierToStyleMap? = nil
  fileprivate var _oldIdentifierToStyleMap: KN_CommandShowChangeThemeArchive.IdentifierToStyleMap? = nil
}

struct KN_CommandShowChangeSlideSizeArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var size: TSP_Size {
    get {return _size ?? TSP_Size()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _size: TSP_Size? = nil
}

struct KN_CommandSetThemeCustomEffectTimingCurveArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var pathSource: TSD_PathSourceArchive {
    get {return _pathSource ?? TSD_PathSourceArchive()}
    set {_pathSource = newValue}
  }
  /// Returns true if `pathSource` has been explicitly set.
  var hasPathSource: Bool {return self._pathSource != nil}
  /// Clears the value of `pathSource`. Subsequent reads from it will return its default value.
  mutating func clearPathSource() {self._pathSource = nil}

  var oldPathSource: TSD_PathSourceArchive {
    get {return _oldPathSource ?? TSD_PathSourceArchive()}
    set {_oldPathSource = newValue}
  }
  /// Returns true if `oldPathSource` has been explicitly set.
  var hasOldPathSource: Bool {return self._oldPathSource != nil}
  /// Clears the value of `oldPathSource`. Subsequent reads from it will return its default value.
  mutating func clearOldPathSource() {self._oldPathSource = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _name: String? = nil
  fileprivate var _pathSource: TSD_PathSourceArchive? = nil
  fileprivate var _oldPathSource: TSD_PathSourceArchive? = nil
}

struct KN_CommandMoveMastersArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_ContainerReorderChildrenCommandArchive {
    get {return _super ?? TSD_ContainerReorderChildrenCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var masterSlides: [TSP_Reference] = []

  var previousIndexesKeys: [TSP_Reference] = []

  var previousIndexesValues: [UInt32] = []

  var finalMasterArrangement: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_ContainerReorderChildrenCommandArchive? = nil
}

struct KN_CommandInsertMasterArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var undoMasterChangeCommands: [TSP_Reference] = []

  var setInsertedSlideAsDefaultMasterSlide: Bool {
    get {return _setInsertedSlideAsDefaultMasterSlide ?? false}
    set {_setInsertedSlideAsDefaultMasterSlide = newValue}
  }
  /// Returns true if `setInsertedSlideAsDefaultMasterSlide` has been explicitly set.
  var hasSetInsertedSlideAsDefaultMasterSlide: Bool {return self._setInsertedSlideAsDefaultMasterSlide != nil}
  /// Clears the value of `setInsertedSlideAsDefaultMasterSlide`. Subsequent reads from it will return its default value.
  mutating func clearSetInsertedSlideAsDefaultMasterSlide() {self._setInsertedSlideAsDefaultMasterSlide = nil}

  var undoReplacementMasterSlideNode: TSP_Reference {
    get {return _undoReplacementMasterSlideNode ?? TSP_Reference()}
    set {_undoReplacementMasterSlideNode = newValue}
  }
  /// Returns true if `undoReplacementMasterSlideNode` has been explicitly set.
  var hasUndoReplacementMasterSlideNode: Bool {return self._undoReplacementMasterSlideNode != nil}
  /// Clears the value of `undoReplacementMasterSlideNode`. Subsequent reads from it will return its default value.
  mutating func clearUndoReplacementMasterSlideNode() {self._undoReplacementMasterSlideNode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _setInsertedSlideAsDefaultMasterSlide: Bool? = nil
  fileprivate var _undoReplacementMasterSlideNode: TSP_Reference? = nil
}

struct KN_CommandPrimitiveInsertMasterArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_ContainerInsertChildrenCommandArchive {
    get {return _super ?? TSD_ContainerInsertChildrenCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var wasInsertedWithDrop: Bool {
    get {return _wasInsertedWithDrop ?? false}
    set {_wasInsertedWithDrop = newValue}
  }
  /// Returns true if `wasInsertedWithDrop` has been explicitly set.
  var hasWasInsertedWithDrop: Bool {return self._wasInsertedWithDrop != nil}
  /// Clears the value of `wasInsertedWithDrop`. Subsequent reads from it will return its default value.
  mutating func clearWasInsertedWithDrop() {self._wasInsertedWithDrop = nil}

  var customFormatKeys: [TSP_UUID] = []

  var previousClassicThemeRecords: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_ContainerInsertChildrenCommandArchive? = nil
  fileprivate var _wasInsertedWithDrop: Bool? = nil
}

struct KN_CommandRemoveMasterArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var replacementMasterSlideNode: TSP_Reference {
    get {return _replacementMasterSlideNode ?? TSP_Reference()}
    set {_replacementMasterSlideNode = newValue}
  }
  /// Returns true if `replacementMasterSlideNode` has been explicitly set.
  var hasReplacementMasterSlideNode: Bool {return self._replacementMasterSlideNode != nil}
  /// Clears the value of `replacementMasterSlideNode`. Subsequent reads from it will return its default value.
  mutating func clearReplacementMasterSlideNode() {self._replacementMasterSlideNode = nil}

  var masterChangeCommands: [TSP_Reference] = []

  var defaultMasterSlideNodeWasReplaced: Bool {
    get {return _defaultMasterSlideNodeWasReplaced ?? false}
    set {_defaultMasterSlideNodeWasReplaced = newValue}
  }
  /// Returns true if `defaultMasterSlideNodeWasReplaced` has been explicitly set.
  var hasDefaultMasterSlideNodeWasReplaced: Bool {return self._defaultMasterSlideNodeWasReplaced != nil}
  /// Clears the value of `defaultMasterSlideNodeWasReplaced`. Subsequent reads from it will return its default value.
  mutating func clearDefaultMasterSlideNodeWasReplaced() {self._defaultMasterSlideNodeWasReplaced = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _replacementMasterSlideNode: TSP_Reference? = nil
  fileprivate var _defaultMasterSlideNodeWasReplaced: Bool? = nil
}

struct KN_CommandPrimitiveRemoveMasterArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_ContainerRemoveChildrenCommandArchive {
    get {return _super ?? TSD_ContainerRemoveChildrenCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var previousClassicThemeRecords: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_ContainerRemoveChildrenCommandArchive? = nil
}

struct KN_CommandSlideInsertBuildArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var insertBuildDescription: TSP_Reference {
    get {return _insertBuildDescription ?? TSP_Reference()}
    set {_insertBuildDescription = newValue}
  }
  /// Returns true if `insertBuildDescription` has been explicitly set.
  var hasInsertBuildDescription: Bool {return self._insertBuildDescription != nil}
  /// Clears the value of `insertBuildDescription`. Subsequent reads from it will return its default value.
  mutating func clearInsertBuildDescription() {self._insertBuildDescription = nil}

  var identifierForChunkToInsertAfter: KN_BuildChunkIdentifierArchive {
    get {return _identifierForChunkToInsertAfter ?? KN_BuildChunkIdentifierArchive()}
    set {_identifierForChunkToInsertAfter = newValue}
  }
  /// Returns true if `identifierForChunkToInsertAfter` has been explicitly set.
  var hasIdentifierForChunkToInsertAfter: Bool {return self._identifierForChunkToInsertAfter != nil}
  /// Clears the value of `identifierForChunkToInsertAfter`. Subsequent reads from it will return its default value.
  mutating func clearIdentifierForChunkToInsertAfter() {self._identifierForChunkToInsertAfter = nil}

  var shouldCreateChunks: Bool {
    get {return _shouldCreateChunks ?? false}
    set {_shouldCreateChunks = newValue}
  }
  /// Returns true if `shouldCreateChunks` has been explicitly set.
  var hasShouldCreateChunks: Bool {return self._shouldCreateChunks != nil}
  /// Clears the value of `shouldCreateChunks`. Subsequent reads from it will return its default value.
  mutating func clearShouldCreateChunks() {self._shouldCreateChunks = nil}

  var oldTuplesToUpdate: [TSP_Reference] = []

  var wasInitializedOverTheWire: Bool {
    get {return _wasInitializedOverTheWire ?? false}
    set {_wasInitializedOverTheWire = newValue}
  }
  /// Returns true if `wasInitializedOverTheWire` has been explicitly set.
  var hasWasInitializedOverTheWire: Bool {return self._wasInitializedOverTheWire != nil}
  /// Clears the value of `wasInitializedOverTheWire`. Subsequent reads from it will return its default value.
  mutating func clearWasInitializedOverTheWire() {self._wasInitializedOverTheWire = nil}

  var hasBeenCommitted_p: Bool {
    get {return _hasBeenCommitted_p ?? false}
    set {_hasBeenCommitted_p = newValue}
  }
  /// Returns true if `hasBeenCommitted_p` has been explicitly set.
  var hasHasBeenCommitted_p: Bool {return self._hasBeenCommitted_p != nil}
  /// Clears the value of `hasBeenCommitted_p`. Subsequent reads from it will return its default value.
  mutating func clearHasBeenCommitted_p() {self._hasBeenCommitted_p = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _insertBuildDescription: TSP_Reference? = nil
  fileprivate var _identifierForChunkToInsertAfter: KN_BuildChunkIdentifierArchive? = nil
  fileprivate var _shouldCreateChunks: Bool? = nil
  fileprivate var _wasInitializedOverTheWire: Bool? = nil
  fileprivate var _hasBeenCommitted_p: Bool? = nil
}

struct KN_InsertBuildDescriptionArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var slideID: TSP_UUID {
    get {return _slideID ?? TSP_UUID()}
    set {_slideID = newValue}
  }
  /// Returns true if `slideID` has been explicitly set.
  var hasSlideID: Bool {return self._slideID != nil}
  /// Clears the value of `slideID`. Subsequent reads from it will return its default value.
  mutating func clearSlideID() {self._slideID = nil}

  var buildToInsert: TSP_Reference {
    get {return _buildToInsert ?? TSP_Reference()}
    set {_buildToInsert = newValue}
  }
  /// Returns true if `buildToInsert` has been explicitly set.
  var hasBuildToInsert: Bool {return self._buildToInsert != nil}
  /// Clears the value of `buildToInsert`. Subsequent reads from it will return its default value.
  mutating func clearBuildToInsert() {self._buildToInsert = nil}

  var chunksToInsert: [TSP_Reference] = []

  var shouldAssignChunkIdentifiers: Bool {
    get {return _shouldAssignChunkIdentifiers ?? false}
    set {_shouldAssignChunkIdentifiers = newValue}
  }
  /// Returns true if `shouldAssignChunkIdentifiers` has been explicitly set.
  var hasShouldAssignChunkIdentifiers: Bool {return self._shouldAssignChunkIdentifiers != nil}
  /// Clears the value of `shouldAssignChunkIdentifiers`. Subsequent reads from it will return its default value.
  mutating func clearShouldAssignChunkIdentifiers() {self._shouldAssignChunkIdentifiers = nil}

  var identifersForChunksToInsertAfter: [KN_BuildChunkIdentifierArchive] = []

  var tuplesToUpdate: [TSP_Reference] = []

  var fallbackChunkIdentifiers: [KN_BuildChunkIdentifierArchive] = []

  var isForPaste: Bool {
    get {return _isForPaste ?? false}
    set {_isForPaste = newValue}
  }
  /// Returns true if `isForPaste` has been explicitly set.
  var hasIsForPaste: Bool {return self._isForPaste != nil}
  /// Clears the value of `isForPaste`. Subsequent reads from it will return its default value.
  mutating func clearIsForPaste() {self._isForPaste = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _slideID: TSP_UUID? = nil
  fileprivate var _buildToInsert: TSP_Reference? = nil
  fileprivate var _shouldAssignChunkIdentifiers: Bool? = nil
  fileprivate var _isForPaste: Bool? = nil
}

struct KN_UndoObjectArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_UndoObjectArchive {
    get {return _super ?? TSD_UndoObjectArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_UndoObjectArchive? = nil
}

struct KN_CommandSlideRemoveBuildArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var removeBuildDescription: TSP_Reference {
    get {return _removeBuildDescription ?? TSP_Reference()}
    set {_removeBuildDescription = newValue}
  }
  /// Returns true if `removeBuildDescription` has been explicitly set.
  var hasRemoveBuildDescription: Bool {return self._removeBuildDescription != nil}
  /// Clears the value of `removeBuildDescription`. Subsequent reads from it will return its default value.
  mutating func clearRemoveBuildDescription() {self._removeBuildDescription = nil}

  var build: TSP_Reference {
    get {return _build ?? TSP_Reference()}
    set {_build = newValue}
  }
  /// Returns true if `build` has been explicitly set.
  var hasBuild: Bool {return self._build != nil}
  /// Clears the value of `build`. Subsequent reads from it will return its default value.
  mutating func clearBuild() {self._build = nil}

  var chunksToInsert: [TSP_Reference] = []

  var identifiersForChunksToInsertAfter: [KN_BuildChunkIdentifierArchive] = []

  var oldTuplesToUpdate: [TSP_Reference] = []

  var fallbackChunkIdentifiers: [KN_BuildChunkIdentifierArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _removeBuildDescription: TSP_Reference? = nil
  fileprivate var _build: TSP_Reference? = nil
}

struct KN_RemoveBuildDescriptionArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var slideID: TSP_UUID {
    get {return _slideID ?? TSP_UUID()}
    set {_slideID = newValue}
  }
  /// Returns true if `slideID` has been explicitly set.
  var hasSlideID: Bool {return self._slideID != nil}
  /// Clears the value of `slideID`. Subsequent reads from it will return its default value.
  mutating func clearSlideID() {self._slideID = nil}

  var buildID: TSP_UUID {
    get {return _buildID ?? TSP_UUID()}
    set {_buildID = newValue}
  }
  /// Returns true if `buildID` has been explicitly set.
  var hasBuildID: Bool {return self._buildID != nil}
  /// Clears the value of `buildID`. Subsequent reads from it will return its default value.
  mutating func clearBuildID() {self._buildID = nil}

  var shouldRemoveChunks: Bool {
    get {return _shouldRemoveChunks ?? false}
    set {_shouldRemoveChunks = newValue}
  }
  /// Returns true if `shouldRemoveChunks` has been explicitly set.
  var hasShouldRemoveChunks: Bool {return self._shouldRemoveChunks != nil}
  /// Clears the value of `shouldRemoveChunks`. Subsequent reads from it will return its default value.
  mutating func clearShouldRemoveChunks() {self._shouldRemoveChunks = nil}

  var shouldRemoveChunkIdentifiers: Bool {
    get {return _shouldRemoveChunkIdentifiers ?? false}
    set {_shouldRemoveChunkIdentifiers = newValue}
  }
  /// Returns true if `shouldRemoveChunkIdentifiers` has been explicitly set.
  var hasShouldRemoveChunkIdentifiers: Bool {return self._shouldRemoveChunkIdentifiers != nil}
  /// Clears the value of `shouldRemoveChunkIdentifiers`. Subsequent reads from it will return its default value.
  mutating func clearShouldRemoveChunkIdentifiers() {self._shouldRemoveChunkIdentifiers = nil}

  var tuplesToUpdate: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _slideID: TSP_UUID? = nil
  fileprivate var _buildID: TSP_UUID? = nil
  fileprivate var _shouldRemoveChunks: Bool? = nil
  fileprivate var _shouldRemoveChunkIdentifiers: Bool? = nil
}

struct KN_CommandSlideInsertBuildChunkArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideID: TSP_UUID {
    get {return _slideID ?? TSP_UUID()}
    set {_slideID = newValue}
  }
  /// Returns true if `slideID` has been explicitly set.
  var hasSlideID: Bool {return self._slideID != nil}
  /// Clears the value of `slideID`. Subsequent reads from it will return its default value.
  mutating func clearSlideID() {self._slideID = nil}

  var chunkToInsert: TSP_Reference {
    get {return _chunkToInsert ?? TSP_Reference()}
    set {_chunkToInsert = newValue}
  }
  /// Returns true if `chunkToInsert` has been explicitly set.
  var hasChunkToInsert: Bool {return self._chunkToInsert != nil}
  /// Clears the value of `chunkToInsert`. Subsequent reads from it will return its default value.
  mutating func clearChunkToInsert() {self._chunkToInsert = nil}

  var identifierForChunkToInsertAfter: KN_BuildChunkIdentifierArchive {
    get {return _identifierForChunkToInsertAfter ?? KN_BuildChunkIdentifierArchive()}
    set {_identifierForChunkToInsertAfter = newValue}
  }
  /// Returns true if `identifierForChunkToInsertAfter` has been explicitly set.
  var hasIdentifierForChunkToInsertAfter: Bool {return self._identifierForChunkToInsertAfter != nil}
  /// Clears the value of `identifierForChunkToInsertAfter`. Subsequent reads from it will return its default value.
  mutating func clearIdentifierForChunkToInsertAfter() {self._identifierForChunkToInsertAfter = nil}

  var tuplesToUpdate: [TSP_Reference] = []

  var oldTuplesToUpdate: [TSP_Reference] = []

  var needsSelectionUpdate: Bool {
    get {return _needsSelectionUpdate ?? false}
    set {_needsSelectionUpdate = newValue}
  }
  /// Returns true if `needsSelectionUpdate` has been explicitly set.
  var hasNeedsSelectionUpdate: Bool {return self._needsSelectionUpdate != nil}
  /// Clears the value of `needsSelectionUpdate`. Subsequent reads from it will return its default value.
  mutating func clearNeedsSelectionUpdate() {self._needsSelectionUpdate = nil}

  var shouldAssignChunkIdentifier: Bool {
    get {return _shouldAssignChunkIdentifier ?? false}
    set {_shouldAssignChunkIdentifier = newValue}
  }
  /// Returns true if `shouldAssignChunkIdentifier` has been explicitly set.
  var hasShouldAssignChunkIdentifier: Bool {return self._shouldAssignChunkIdentifier != nil}
  /// Clears the value of `shouldAssignChunkIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearShouldAssignChunkIdentifier() {self._shouldAssignChunkIdentifier = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideID: TSP_UUID? = nil
  fileprivate var _chunkToInsert: TSP_Reference? = nil
  fileprivate var _identifierForChunkToInsertAfter: KN_BuildChunkIdentifierArchive? = nil
  fileprivate var _needsSelectionUpdate: Bool? = nil
  fileprivate var _shouldAssignChunkIdentifier: Bool? = nil
}

struct KN_CommandSlideRemoveBuildChunkArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideID: TSP_UUID {
    get {return _slideID ?? TSP_UUID()}
    set {_slideID = newValue}
  }
  /// Returns true if `slideID` has been explicitly set.
  var hasSlideID: Bool {return self._slideID != nil}
  /// Clears the value of `slideID`. Subsequent reads from it will return its default value.
  mutating func clearSlideID() {self._slideID = nil}

  var removedChunk: TSP_Reference {
    get {return _removedChunk ?? TSP_Reference()}
    set {_removedChunk = newValue}
  }
  /// Returns true if `removedChunk` has been explicitly set.
  var hasRemovedChunk: Bool {return self._removedChunk != nil}
  /// Clears the value of `removedChunk`. Subsequent reads from it will return its default value.
  mutating func clearRemovedChunk() {self._removedChunk = nil}

  var identifierForChunkToRemove: KN_BuildChunkIdentifierArchive {
    get {return _identifierForChunkToRemove ?? KN_BuildChunkIdentifierArchive()}
    set {_identifierForChunkToRemove = newValue}
  }
  /// Returns true if `identifierForChunkToRemove` has been explicitly set.
  var hasIdentifierForChunkToRemove: Bool {return self._identifierForChunkToRemove != nil}
  /// Clears the value of `identifierForChunkToRemove`. Subsequent reads from it will return its default value.
  mutating func clearIdentifierForChunkToRemove() {self._identifierForChunkToRemove = nil}

  var identifierForChunkToInsertAfter: KN_BuildChunkIdentifierArchive {
    get {return _identifierForChunkToInsertAfter ?? KN_BuildChunkIdentifierArchive()}
    set {_identifierForChunkToInsertAfter = newValue}
  }
  /// Returns true if `identifierForChunkToInsertAfter` has been explicitly set.
  var hasIdentifierForChunkToInsertAfter: Bool {return self._identifierForChunkToInsertAfter != nil}
  /// Clears the value of `identifierForChunkToInsertAfter`. Subsequent reads from it will return its default value.
  mutating func clearIdentifierForChunkToInsertAfter() {self._identifierForChunkToInsertAfter = nil}

  var tuplesToUpdate: [TSP_Reference] = []

  var oldTuplesToUpdate: [TSP_Reference] = []

  var needsSelectionUpdate: Bool {
    get {return _needsSelectionUpdate ?? false}
    set {_needsSelectionUpdate = newValue}
  }
  /// Returns true if `needsSelectionUpdate` has been explicitly set.
  var hasNeedsSelectionUpdate: Bool {return self._needsSelectionUpdate != nil}
  /// Clears the value of `needsSelectionUpdate`. Subsequent reads from it will return its default value.
  mutating func clearNeedsSelectionUpdate() {self._needsSelectionUpdate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideID: TSP_UUID? = nil
  fileprivate var _removedChunk: TSP_Reference? = nil
  fileprivate var _identifierForChunkToRemove: KN_BuildChunkIdentifierArchive? = nil
  fileprivate var _identifierForChunkToInsertAfter: KN_BuildChunkIdentifierArchive? = nil
  fileprivate var _needsSelectionUpdate: Bool? = nil
}

struct KN_CommandSlideMoveBuildChunksArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var identifiersForChunksToMove: [KN_BuildChunkIdentifierArchive] = []

  var identifiersForChunksToMoveAfter: [KN_BuildChunkIdentifierArchive] = []

  var identifiersForChunksToMoveAfterForUndo: [KN_BuildChunkIdentifierArchive] = []

  var tuplesToUpdate: [TSP_Reference] = []

  var oldTuplesToUpdate: [TSP_Reference] = []

  var identifiersForChunksToMoveIncludingClusteredInactiveChunks: [KN_BuildChunkIdentifierArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
}

struct KN_CommandBuildSetValueArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var tuple: TSP_Reference {
    get {return _tuple ?? TSP_Reference()}
    set {_tuple = newValue}
  }
  /// Returns true if `tuple` has been explicitly set.
  var hasTuple: Bool {return self._tuple != nil}
  /// Clears the value of `tuple`. Subsequent reads from it will return its default value.
  mutating func clearTuple() {self._tuple = nil}

  var chunksToAdd: [TSP_Reference] = []

  var identifiersForChunksToInsertAfter: [KN_BuildChunkIdentifierArchive] = []

  var identifiersForChunksToRemove: [KN_BuildChunkIdentifierArchive] = []

  var tuplesToUpdate: [TSP_Reference] = []

  var oldTupleForMainProperty: TSP_Reference {
    get {return _oldTupleForMainProperty ?? TSP_Reference()}
    set {_oldTupleForMainProperty = newValue}
  }
  /// Returns true if `oldTupleForMainProperty` has been explicitly set.
  var hasOldTupleForMainProperty: Bool {return self._oldTupleForMainProperty != nil}
  /// Clears the value of `oldTupleForMainProperty`. Subsequent reads from it will return its default value.
  mutating func clearOldTupleForMainProperty() {self._oldTupleForMainProperty = nil}

  var oldTuplesToUpdateForSubCommands: [TSP_Reference] = []

  var identifiersForAddedChunks: [KN_BuildChunkIdentifierArchive] = []

  var generatedIdentifiers: [KN_BuildChunkIdentifierArchive] = []

  var removedChunks: [TSP_Reference] = []

  var identifiersForChunksPriorToRemovedChunks: [KN_BuildChunkIdentifierArchive] = []

  var oldChunkIDSeed: UInt32 {
    get {return _oldChunkIDSeed ?? 0}
    set {_oldChunkIDSeed = newValue}
  }
  /// Returns true if `oldChunkIDSeed` has been explicitly set.
  var hasOldChunkIDSeed: Bool {return self._oldChunkIDSeed != nil}
  /// Clears the value of `oldChunkIDSeed`. Subsequent reads from it will return its default value.
  mutating func clearOldChunkIDSeed() {self._oldChunkIDSeed = nil}

  var oldChunkIdentifiers: [KN_BuildChunkIdentifierArchive] = []

  var chunksRemovedDuringUndo: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _tuple: TSP_Reference? = nil
  fileprivate var _oldTupleForMainProperty: TSP_Reference? = nil
  fileprivate var _oldChunkIDSeed: UInt32? = nil
}

struct KN_CommandBuildUpdateChunkReferentsArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var buildID: TSP_UUID {
    get {return _buildID ?? TSP_UUID()}
    set {_buildID = newValue}
  }
  /// Returns true if `buildID` has been explicitly set.
  var hasBuildID: Bool {return self._buildID != nil}
  /// Clears the value of `buildID`. Subsequent reads from it will return its default value.
  mutating func clearBuildID() {self._buildID = nil}

  var tuplesToUpdate: [TSP_Reference] = []

  var oldTuplesToUpdate: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _buildID: TSP_UUID? = nil
}

struct KN_CommandBuildUpdateChunkCountArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var slideID: TSP_UUID {
    get {return _storage._slideID ?? TSP_UUID()}
    set {_uniqueStorage()._slideID = newValue}
  }
  /// Returns true if `slideID` has been explicitly set.
  var hasSlideID: Bool {return _storage._slideID != nil}
  /// Clears the value of `slideID`. Subsequent reads from it will return its default value.
  mutating func clearSlideID() {_uniqueStorage()._slideID = nil}

  var drawableIds: [TSP_UUID] {
    get {return _storage._drawableIds}
    set {_uniqueStorage()._drawableIds = newValue}
  }

  var expectedDeliveryStyleTuples: [TSP_Reference] {
    get {return _storage._expectedDeliveryStyleTuples}
    set {_uniqueStorage()._expectedDeliveryStyleTuples = newValue}
  }

  var chunksToAdd: [TSP_Reference] {
    get {return _storage._chunksToAdd}
    set {_uniqueStorage()._chunksToAdd = newValue}
  }

  var identifiersForChunksToInsertAfter: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._identifiersForChunksToInsertAfter}
    set {_uniqueStorage()._identifiersForChunksToInsertAfter = newValue}
  }

  var identifiersForChunksToRemove: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._identifiersForChunksToRemove}
    set {_uniqueStorage()._identifiersForChunksToRemove = newValue}
  }

  var tuplesToUpdate: [TSP_Reference] {
    get {return _storage._tuplesToUpdate}
    set {_uniqueStorage()._tuplesToUpdate = newValue}
  }

  var needsAsyncProcessChangesSelectionUpdate: Bool {
    get {return _storage._needsAsyncProcessChangesSelectionUpdate ?? false}
    set {_uniqueStorage()._needsAsyncProcessChangesSelectionUpdate = newValue}
  }
  /// Returns true if `needsAsyncProcessChangesSelectionUpdate` has been explicitly set.
  var hasNeedsAsyncProcessChangesSelectionUpdate: Bool {return _storage._needsAsyncProcessChangesSelectionUpdate != nil}
  /// Clears the value of `needsAsyncProcessChangesSelectionUpdate`. Subsequent reads from it will return its default value.
  mutating func clearNeedsAsyncProcessChangesSelectionUpdate() {_uniqueStorage()._needsAsyncProcessChangesSelectionUpdate = nil}

  var oldTuplesToUpdate: [TSP_Reference] {
    get {return _storage._oldTuplesToUpdate}
    set {_uniqueStorage()._oldTuplesToUpdate = newValue}
  }

  var identifiersForAddedChunks: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._identifiersForAddedChunks}
    set {_uniqueStorage()._identifiersForAddedChunks = newValue}
  }

  var generatedIdentifiers: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._generatedIdentifiers}
    set {_uniqueStorage()._generatedIdentifiers = newValue}
  }

  var removedChunks: [TSP_Reference] {
    get {return _storage._removedChunks}
    set {_uniqueStorage()._removedChunks = newValue}
  }

  var identifiersForChunksPriorToRemovedChunks: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._identifiersForChunksPriorToRemovedChunks}
    set {_uniqueStorage()._identifiersForChunksPriorToRemovedChunks = newValue}
  }

  var oldDeliveryStyleTuples: [TSP_Reference] {
    get {return _storage._oldDeliveryStyleTuples}
    set {_uniqueStorage()._oldDeliveryStyleTuples = newValue}
  }

  var oldChunkIDSeeds: [UInt32] {
    get {return _storage._oldChunkIDSeeds}
    set {_uniqueStorage()._oldChunkIDSeeds = newValue}
  }

  var oldChunkIdentifiers: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._oldChunkIdentifiers}
    set {_uniqueStorage()._oldChunkIdentifiers = newValue}
  }

  var workingBuilds: [TSP_Reference] {
    get {return _storage._workingBuilds}
    set {_uniqueStorage()._workingBuilds = newValue}
  }

  var chunksRemovedDuringUndo: [TSP_Reference] {
    get {return _storage._chunksRemovedDuringUndo}
    set {_uniqueStorage()._chunksRemovedDuringUndo = newValue}
  }

  var chunksAddedDuringUndo: [TSP_Reference] {
    get {return _storage._chunksAddedDuringUndo}
    set {_uniqueStorage()._chunksAddedDuringUndo = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandBuildChunkSetValueArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var tuplesToUpdate: [TSP_Reference] = []

  var oldTuplesToUpdate: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
}

struct KN_CommandTransitionSetValueArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideNodeIDPath: TSP_UUIDPath {
    get {return _slideNodeIDPath ?? TSP_UUIDPath()}
    set {_slideNodeIDPath = newValue}
  }
  /// Returns true if `slideNodeIDPath` has been explicitly set.
  var hasSlideNodeIDPath: Bool {return self._slideNodeIDPath != nil}
  /// Clears the value of `slideNodeIDPath`. Subsequent reads from it will return its default value.
  mutating func clearSlideNodeIDPath() {self._slideNodeIDPath = nil}

  var oldAttributes: KN_TransitionAttributesArchive {
    get {return _oldAttributes ?? KN_TransitionAttributesArchive()}
    set {_oldAttributes = newValue}
  }
  /// Returns true if `oldAttributes` has been explicitly set.
  var hasOldAttributes: Bool {return self._oldAttributes != nil}
  /// Clears the value of `oldAttributes`. Subsequent reads from it will return its default value.
  mutating func clearOldAttributes() {self._oldAttributes = nil}

  var attributes: KN_TransitionAttributesArchive {
    get {return _attributes ?? KN_TransitionAttributesArchive()}
    set {_attributes = newValue}
  }
  /// Returns true if `attributes` has been explicitly set.
  var hasAttributes: Bool {return self._attributes != nil}
  /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
  mutating func clearAttributes() {self._attributes = nil}

  var property: String {
    get {return _property ?? String()}
    set {_property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return self._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {self._property = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideNodeIDPath: TSP_UUIDPath? = nil
  fileprivate var _oldAttributes: KN_TransitionAttributesArchive? = nil
  fileprivate var _attributes: KN_TransitionAttributesArchive? = nil
  fileprivate var _property: String? = nil
}

struct KN_CommandShowSetSlideNumberVisibilityArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideNumbersVisible: Bool {
    get {return _slideNumbersVisible ?? false}
    set {_slideNumbersVisible = newValue}
  }
  /// Returns true if `slideNumbersVisible` has been explicitly set.
  var hasSlideNumbersVisible: Bool {return self._slideNumbersVisible != nil}
  /// Clears the value of `slideNumbersVisible`. Subsequent reads from it will return its default value.
  mutating func clearSlideNumbersVisible() {self._slideNumbersVisible = nil}

  var idsOfSlideNodesToSkip: [TSP_UUID] = []

  var idsOfSlideNodesAlreadyCorrect: [TSP_UUID] = []

  var isUndo: Bool {
    get {return _isUndo ?? false}
    set {_isUndo = newValue}
  }
  /// Returns true if `isUndo` has been explicitly set.
  var hasIsUndo: Bool {return self._isUndo != nil}
  /// Clears the value of `isUndo`. Subsequent reads from it will return its default value.
  mutating func clearIsUndo() {self._isUndo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideNumbersVisible: Bool? = nil
  fileprivate var _isUndo: Bool? = nil
}

struct KN_CommandMasterSetThumbnailTextArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var masterID: TSP_UUID {
    get {return _masterID ?? TSP_UUID()}
    set {_masterID = newValue}
  }
  /// Returns true if `masterID` has been explicitly set.
  var hasMasterID: Bool {return self._masterID != nil}
  /// Clears the value of `masterID`. Subsequent reads from it will return its default value.
  mutating func clearMasterID() {self._masterID = nil}

  var isBody: Bool {
    get {return _isBody ?? false}
    set {_isBody = newValue}
  }
  /// Returns true if `isBody` has been explicitly set.
  var hasIsBody: Bool {return self._isBody != nil}
  /// Clears the value of `isBody`. Subsequent reads from it will return its default value.
  mutating func clearIsBody() {self._isBody = nil}

  var newText: String {
    get {return _newText ?? String()}
    set {_newText = newValue}
  }
  /// Returns true if `newText` has been explicitly set.
  var hasNewText: Bool {return self._newText != nil}
  /// Clears the value of `newText`. Subsequent reads from it will return its default value.
  mutating func clearNewText() {self._newText = nil}

  var oldText: String {
    get {return _oldText ?? String()}
    set {_oldText = newValue}
  }
  /// Returns true if `oldText` has been explicitly set.
  var hasOldText: Bool {return self._oldText != nil}
  /// Clears the value of `oldText`. Subsequent reads from it will return its default value.
  mutating func clearOldText() {self._oldText = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _masterID: TSP_UUID? = nil
  fileprivate var _isBody: Bool? = nil
  fileprivate var _newText: String? = nil
  fileprivate var _oldText: String? = nil
}

struct KN_CommandMasterSetBodyStylesArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var masterID: TSP_UUID {
    get {return _masterID ?? TSP_UUID()}
    set {_masterID = newValue}
  }
  /// Returns true if `masterID` has been explicitly set.
  var hasMasterID: Bool {return self._masterID != nil}
  /// Clears the value of `masterID`. Subsequent reads from it will return its default value.
  mutating func clearMasterID() {self._masterID = nil}

  var newParagraphStyles: [TSP_Reference] = []

  var newListStyles: [TSP_Reference] = []

  var oldParagraphStyles: [TSP_Reference] = []

  var oldListStyles: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _masterID: TSP_UUID? = nil
}

struct KN_CommandChangeMasterSlideArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideIDPath: TSP_UUIDPath {
    get {return _slideIDPath ?? TSP_UUIDPath()}
    set {_slideIDPath = newValue}
  }
  /// Returns true if `slideIDPath` has been explicitly set.
  var hasSlideIDPath: Bool {return self._slideIDPath != nil}
  /// Clears the value of `slideIDPath`. Subsequent reads from it will return its default value.
  mutating func clearSlideIDPath() {self._slideIDPath = nil}

  var masterNode: TSP_Reference {
    get {return _masterNode ?? TSP_Reference()}
    set {_masterNode = newValue}
  }
  /// Returns true if `masterNode` has been explicitly set.
  var hasMasterNode: Bool {return self._masterNode != nil}
  /// Clears the value of `masterNode`. Subsequent reads from it will return its default value.
  mutating func clearMasterNode() {self._masterNode = nil}

  var oldMasterNode: TSP_Reference {
    get {return _oldMasterNode ?? TSP_Reference()}
    set {_oldMasterNode = newValue}
  }
  /// Returns true if `oldMasterNode` has been explicitly set.
  var hasOldMasterNode: Bool {return self._oldMasterNode != nil}
  /// Clears the value of `oldMasterNode`. Subsequent reads from it will return its default value.
  mutating func clearOldMasterNode() {self._oldMasterNode = nil}

  var isUndoRedo: Bool {
    get {return _isUndoRedo ?? false}
    set {_isUndoRedo = newValue}
  }
  /// Returns true if `isUndoRedo` has been explicitly set.
  var hasIsUndoRedo: Bool {return self._isUndoRedo != nil}
  /// Clears the value of `isUndoRedo`. Subsequent reads from it will return its default value.
  mutating func clearIsUndoRedo() {self._isUndoRedo = nil}

  var targetPrototype: TSP_Reference {
    get {return _targetPrototype ?? TSP_Reference()}
    set {_targetPrototype = newValue}
  }
  /// Returns true if `targetPrototype` has been explicitly set.
  var hasTargetPrototype: Bool {return self._targetPrototype != nil}
  /// Clears the value of `targetPrototype`. Subsequent reads from it will return its default value.
  mutating func clearTargetPrototype() {self._targetPrototype = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideIDPath: TSP_UUIDPath? = nil
  fileprivate var _masterNode: TSP_Reference? = nil
  fileprivate var _oldMasterNode: TSP_Reference? = nil
  fileprivate var _isUndoRedo: Bool? = nil
  fileprivate var _targetPrototype: TSP_Reference? = nil
}

struct KN_CommandSlidePrimitiveSetMasterArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideIDPath: TSP_UUIDPath {
    get {return _slideIDPath ?? TSP_UUIDPath()}
    set {_slideIDPath = newValue}
  }
  /// Returns true if `slideIDPath` has been explicitly set.
  var hasSlideIDPath: Bool {return self._slideIDPath != nil}
  /// Clears the value of `slideIDPath`. Subsequent reads from it will return its default value.
  mutating func clearSlideIDPath() {self._slideIDPath = nil}

  var masterID: TSP_UUID {
    get {return _masterID ?? TSP_UUID()}
    set {_masterID = newValue}
  }
  /// Returns true if `masterID` has been explicitly set.
  var hasMasterID: Bool {return self._masterID != nil}
  /// Clears the value of `masterID`. Subsequent reads from it will return its default value.
  mutating func clearMasterID() {self._masterID = nil}

  var oldMasterNode: TSP_Reference {
    get {return _oldMasterNode ?? TSP_Reference()}
    set {_oldMasterNode = newValue}
  }
  /// Returns true if `oldMasterNode` has been explicitly set.
  var hasOldMasterNode: Bool {return self._oldMasterNode != nil}
  /// Clears the value of `oldMasterNode`. Subsequent reads from it will return its default value.
  mutating func clearOldMasterNode() {self._oldMasterNode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideIDPath: TSP_UUIDPath? = nil
  fileprivate var _masterID: TSP_UUID? = nil
  fileprivate var _oldMasterNode: TSP_Reference? = nil
}

struct KN_CommandSlideResetMasterBackgroundObjectsArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideIDPath: TSP_UUIDPath {
    get {return _slideIDPath ?? TSP_UUIDPath()}
    set {_slideIDPath = newValue}
  }
  /// Returns true if `slideIDPath` has been explicitly set.
  var hasSlideIDPath: Bool {return self._slideIDPath != nil}
  /// Clears the value of `slideIDPath`. Subsequent reads from it will return its default value.
  mutating func clearSlideIDPath() {self._slideIDPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideIDPath: TSP_UUIDPath? = nil
}

struct KN_CommandShowSetSoundtrack {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var show: TSP_Reference {
    get {return _show ?? TSP_Reference()}
    set {_show = newValue}
  }
  /// Returns true if `show` has been explicitly set.
  var hasShow: Bool {return self._show != nil}
  /// Clears the value of `show`. Subsequent reads from it will return its default value.
  mutating func clearShow() {self._show = nil}

  var soundtrack: TSP_Reference {
    get {return _soundtrack ?? TSP_Reference()}
    set {_soundtrack = newValue}
  }
  /// Returns true if `soundtrack` has been explicitly set.
  var hasSoundtrack: Bool {return self._soundtrack != nil}
  /// Clears the value of `soundtrack`. Subsequent reads from it will return its default value.
  mutating func clearSoundtrack() {self._soundtrack = nil}

  var oldSoundtrack: TSP_Reference {
    get {return _oldSoundtrack ?? TSP_Reference()}
    set {_oldSoundtrack = newValue}
  }
  /// Returns true if `oldSoundtrack` has been explicitly set.
  var hasOldSoundtrack: Bool {return self._oldSoundtrack != nil}
  /// Clears the value of `oldSoundtrack`. Subsequent reads from it will return its default value.
  mutating func clearOldSoundtrack() {self._oldSoundtrack = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _show: TSP_Reference? = nil
  fileprivate var _soundtrack: TSP_Reference? = nil
  fileprivate var _oldSoundtrack: TSP_Reference? = nil
}

struct KN_CommandSoundtrackSetValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var soundtrackID: TSP_UUID {
    get {return _soundtrackID ?? TSP_UUID()}
    set {_soundtrackID = newValue}
  }
  /// Returns true if `soundtrackID` has been explicitly set.
  var hasSoundtrackID: Bool {return self._soundtrackID != nil}
  /// Clears the value of `soundtrackID`. Subsequent reads from it will return its default value.
  mutating func clearSoundtrackID() {self._soundtrackID = nil}

  var property: String {
    get {return _property ?? String()}
    set {_property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return self._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {self._property = nil}

  var oldValue: KN_CommandSoundtrackSetValue.PropertyValue {
    get {return _oldValue ?? KN_CommandSoundtrackSetValue.PropertyValue()}
    set {_oldValue = newValue}
  }
  /// Returns true if `oldValue` has been explicitly set.
  var hasOldValue: Bool {return self._oldValue != nil}
  /// Clears the value of `oldValue`. Subsequent reads from it will return its default value.
  mutating func clearOldValue() {self._oldValue = nil}

  var newValue: KN_CommandSoundtrackSetValue.PropertyValue {
    get {return _newValue ?? KN_CommandSoundtrackSetValue.PropertyValue()}
    set {_newValue = newValue}
  }
  /// Returns true if `newValue` has been explicitly set.
  var hasNewValue: Bool {return self._newValue != nil}
  /// Clears the value of `newValue`. Subsequent reads from it will return its default value.
  mutating func clearNewValue() {self._newValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PropertyValue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var doubleValue: Double {
      get {return _doubleValue ?? 0}
      set {_doubleValue = newValue}
    }
    /// Returns true if `doubleValue` has been explicitly set.
    var hasDoubleValue: Bool {return self._doubleValue != nil}
    /// Clears the value of `doubleValue`. Subsequent reads from it will return its default value.
    mutating func clearDoubleValue() {self._doubleValue = nil}

    var modeValue: KN_Soundtrack.SoundtrackMode {
      get {return _modeValue ?? .kKnsoundtrackModePlayOnce}
      set {_modeValue = newValue}
    }
    /// Returns true if `modeValue` has been explicitly set.
    var hasModeValue: Bool {return self._modeValue != nil}
    /// Clears the value of `modeValue`. Subsequent reads from it will return its default value.
    mutating func clearModeValue() {self._modeValue = nil}

    var mediaReferenceValues: [TSP_DataReference] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _doubleValue: Double? = nil
    fileprivate var _modeValue: KN_Soundtrack.SoundtrackMode? = nil
  }

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _soundtrackID: TSP_UUID? = nil
  fileprivate var _property: String? = nil
  fileprivate var _oldValue: KN_CommandSoundtrackSetValue.PropertyValue? = nil
  fileprivate var _newValue: KN_CommandSoundtrackSetValue.PropertyValue? = nil
}

struct KN_CommandSlideUpdateMasterDrawables {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideID: TSP_UUID {
    get {return _slideID ?? TSP_UUID()}
    set {_slideID = newValue}
  }
  /// Returns true if `slideID` has been explicitly set.
  var hasSlideID: Bool {return self._slideID != nil}
  /// Clears the value of `slideID`. Subsequent reads from it will return its default value.
  mutating func clearSlideID() {self._slideID = nil}

  var idPlacementOperationArgs: [TSK_IdPlacementOperationArgs] = []

  var oldChildInfosForUndo: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideID: TSP_UUID? = nil
}

struct KN_ChartInfoGeometryCommandArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoGeometryCommandArchive {
    get {return _super ?? TSD_InfoGeometryCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var previousLegendOffset: TSP_Point {
    get {return _previousLegendOffset ?? TSP_Point()}
    set {_previousLegendOffset = newValue}
  }
  /// Returns true if `previousLegendOffset` has been explicitly set.
  var hasPreviousLegendOffset: Bool {return self._previousLegendOffset != nil}
  /// Clears the value of `previousLegendOffset`. Subsequent reads from it will return its default value.
  mutating func clearPreviousLegendOffset() {self._previousLegendOffset = nil}

  var previousLegendSize: TSP_Size {
    get {return _previousLegendSize ?? TSP_Size()}
    set {_previousLegendSize = newValue}
  }
  /// Returns true if `previousLegendSize` has been explicitly set.
  var hasPreviousLegendSize: Bool {return self._previousLegendSize != nil}
  /// Clears the value of `previousLegendSize`. Subsequent reads from it will return its default value.
  mutating func clearPreviousLegendSize() {self._previousLegendSize = nil}

  var adjustedLegendOffset: TSP_Point {
    get {return _adjustedLegendOffset ?? TSP_Point()}
    set {_adjustedLegendOffset = newValue}
  }
  /// Returns true if `adjustedLegendOffset` has been explicitly set.
  var hasAdjustedLegendOffset: Bool {return self._adjustedLegendOffset != nil}
  /// Clears the value of `adjustedLegendOffset`. Subsequent reads from it will return its default value.
  mutating func clearAdjustedLegendOffset() {self._adjustedLegendOffset = nil}

  var adjustedLegendSize: TSP_Size {
    get {return _adjustedLegendSize ?? TSP_Size()}
    set {_adjustedLegendSize = newValue}
  }
  /// Returns true if `adjustedLegendSize` has been explicitly set.
  var hasAdjustedLegendSize: Bool {return self._adjustedLegendSize != nil}
  /// Clears the value of `adjustedLegendSize`. Subsequent reads from it will return its default value.
  mutating func clearAdjustedLegendSize() {self._adjustedLegendSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_InfoGeometryCommandArchive? = nil
  fileprivate var _previousLegendOffset: TSP_Point? = nil
  fileprivate var _previousLegendSize: TSP_Size? = nil
  fileprivate var _adjustedLegendOffset: TSP_Point? = nil
  fileprivate var _adjustedLegendSize: TSP_Size? = nil
}

struct KN_CanvasSelectionTransformerArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transformerHelper: TSD_InfoCollectionSelectionTransformerHelperArchive {
    get {return _transformerHelper ?? TSD_InfoCollectionSelectionTransformerHelperArchive()}
    set {_transformerHelper = newValue}
  }
  /// Returns true if `transformerHelper` has been explicitly set.
  var hasTransformerHelper: Bool {return self._transformerHelper != nil}
  /// Clears the value of `transformerHelper`. Subsequent reads from it will return its default value.
  mutating func clearTransformerHelper() {self._transformerHelper = nil}

  var buildChunkIds: [KN_BuildChunkIdentifierArchive] = []

  var actionBuildIds: [TSP_UUID] = []

  var originallySelectedDrawableUuids: [TSP_UUID] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transformerHelper: TSD_InfoCollectionSelectionTransformerHelperArchive? = nil
}

struct KN_ActionGhostSelectionTransformerArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct KN_DocumentSelectionTransformerArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var documentSelection: TSP_Reference {
    get {return _documentSelection ?? TSP_Reference()}
    set {_documentSelection = newValue}
  }
  /// Returns true if `documentSelection` has been explicitly set.
  var hasDocumentSelection: Bool {return self._documentSelection != nil}
  /// Clears the value of `documentSelection`. Subsequent reads from it will return its default value.
  mutating func clearDocumentSelection() {self._documentSelection = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _documentSelection: TSP_Reference? = nil
}

struct KN_NoteCanvasSelectionTransformerArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transformerHelper: TSD_InfoCollectionSelectionTransformerHelperArchive {
    get {return _transformerHelper ?? TSD_InfoCollectionSelectionTransformerHelperArchive()}
    set {_transformerHelper = newValue}
  }
  /// Returns true if `transformerHelper` has been explicitly set.
  var hasTransformerHelper: Bool {return self._transformerHelper != nil}
  /// Clears the value of `transformerHelper`. Subsequent reads from it will return its default value.
  mutating func clearTransformerHelper() {self._transformerHelper = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transformerHelper: TSD_InfoCollectionSelectionTransformerHelperArchive? = nil
}

struct KN_OutlineCanvasSelectionTransformerArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var canvasSelectionTransformer: TSP_Reference {
    get {return _canvasSelectionTransformer ?? TSP_Reference()}
    set {_canvasSelectionTransformer = newValue}
  }
  /// Returns true if `canvasSelectionTransformer` has been explicitly set.
  var hasCanvasSelectionTransformer: Bool {return self._canvasSelectionTransformer != nil}
  /// Clears the value of `canvasSelectionTransformer`. Subsequent reads from it will return its default value.
  mutating func clearCanvasSelectionTransformer() {self._canvasSelectionTransformer = nil}

  var storageUuidPath: TSP_UUIDPath {
    get {return _storageUuidPath ?? TSP_UUIDPath()}
    set {_storageUuidPath = newValue}
  }
  /// Returns true if `storageUuidPath` has been explicitly set.
  var hasStorageUuidPath: Bool {return self._storageUuidPath != nil}
  /// Clears the value of `storageUuidPath`. Subsequent reads from it will return its default value.
  mutating func clearStorageUuidPath() {self._storageUuidPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _canvasSelectionTransformer: TSP_Reference? = nil
  fileprivate var _storageUuidPath: TSP_UUIDPath? = nil
}

struct KN_SlideCollectionSelectionTransformerHelperArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var slideNodes: [TSP_UUIDPath] = []

  var slideNodeToEdit: TSP_UUIDPath {
    get {return _slideNodeToEdit ?? TSP_UUIDPath()}
    set {_slideNodeToEdit = newValue}
  }
  /// Returns true if `slideNodeToEdit` has been explicitly set.
  var hasSlideNodeToEdit: Bool {return self._slideNodeToEdit != nil}
  /// Clears the value of `slideNodeToEdit`. Subsequent reads from it will return its default value.
  mutating func clearSlideNodeToEdit() {self._slideNodeToEdit = nil}

  var slideCollectionIsTheme: Bool {
    get {return _slideCollectionIsTheme ?? false}
    set {_slideCollectionIsTheme = newValue}
  }
  /// Returns true if `slideCollectionIsTheme` has been explicitly set.
  var hasSlideCollectionIsTheme: Bool {return self._slideCollectionIsTheme != nil}
  /// Clears the value of `slideCollectionIsTheme`. Subsequent reads from it will return its default value.
  mutating func clearSlideCollectionIsTheme() {self._slideCollectionIsTheme = nil}

  var previousPrimarySelectedIndex: UInt32 {
    get {return _previousPrimarySelectedIndex ?? 0}
    set {_previousPrimarySelectedIndex = newValue}
  }
  /// Returns true if `previousPrimarySelectedIndex` has been explicitly set.
  var hasPreviousPrimarySelectedIndex: Bool {return self._previousPrimarySelectedIndex != nil}
  /// Clears the value of `previousPrimarySelectedIndex`. Subsequent reads from it will return its default value.
  mutating func clearPreviousPrimarySelectedIndex() {self._previousPrimarySelectedIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _slideNodeToEdit: TSP_UUIDPath? = nil
  fileprivate var _slideCollectionIsTheme: Bool? = nil
  fileprivate var _previousPrimarySelectedIndex: UInt32? = nil
}

struct KN_SlideCollectionSelectionTransformerArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transformerHelper: KN_SlideCollectionSelectionTransformerHelperArchive {
    get {return _transformerHelper ?? KN_SlideCollectionSelectionTransformerHelperArchive()}
    set {_transformerHelper = newValue}
  }
  /// Returns true if `transformerHelper` has been explicitly set.
  var hasTransformerHelper: Bool {return self._transformerHelper != nil}
  /// Clears the value of `transformerHelper`. Subsequent reads from it will return its default value.
  mutating func clearTransformerHelper() {self._transformerHelper = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transformerHelper: KN_SlideCollectionSelectionTransformerHelperArchive? = nil
}

struct KN_OutlineSelectionTransformerArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transformerHelper: KN_SlideCollectionSelectionTransformerHelperArchive {
    get {return _transformerHelper ?? KN_SlideCollectionSelectionTransformerHelperArchive()}
    set {_transformerHelper = newValue}
  }
  /// Returns true if `transformerHelper` has been explicitly set.
  var hasTransformerHelper: Bool {return self._transformerHelper != nil}
  /// Clears the value of `transformerHelper`. Subsequent reads from it will return its default value.
  mutating func clearTransformerHelper() {self._transformerHelper = nil}

  var canHaveRangeInSelectedParagraph: Bool {
    get {return _canHaveRangeInSelectedParagraph ?? false}
    set {_canHaveRangeInSelectedParagraph = newValue}
  }
  /// Returns true if `canHaveRangeInSelectedParagraph` has been explicitly set.
  var hasCanHaveRangeInSelectedParagraph: Bool {return self._canHaveRangeInSelectedParagraph != nil}
  /// Clears the value of `canHaveRangeInSelectedParagraph`. Subsequent reads from it will return its default value.
  mutating func clearCanHaveRangeInSelectedParagraph() {self._canHaveRangeInSelectedParagraph = nil}

  var selectionRangeAddresses: [TSK_RangeAddress] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transformerHelper: KN_SlideCollectionSelectionTransformerHelperArchive? = nil
  fileprivate var _canHaveRangeInSelectedParagraph: Bool? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "KN"

extension KN_AnimationReferent: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kRelativeToStart"),
    2: .same(proto: "kRelativeToEnd"),
  ]
}

extension KN_UIStateCommandGroupArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIStateCommandGroupArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .same(proto: "uiState"),
    3: .same(proto: "property"),
    4: .same(proto: "slideNodesToEdit"),
    5: .same(proto: "masterSlideNodesToApply"),
    6: .same(proto: "thumbnailSizes"),
    7: .same(proto: "selectedSlideNodes"),
    8: .same(proto: "restoreSelectedSlideNodes"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._uiState == nil {return false}
    if self._property == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._uiState, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.slideNodesToEdit) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.masterSlideNodesToApply) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.thumbnailSizes) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.selectedSlideNodes) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.restoreSelectedSlideNodes) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._uiState)
      case 3: try decoder.decodeSingularStringField(value: &self._property)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.slideNodesToEdit)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.masterSlideNodesToApply)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.thumbnailSizes)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.selectedSlideNodes)
      case 8: try decoder.decodeRepeatedMessageField(value: &self.restoreSelectedSlideNodes)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._uiState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._property {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if !self.slideNodesToEdit.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.slideNodesToEdit, fieldNumber: 4)
    }
    if !self.masterSlideNodesToApply.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.masterSlideNodesToApply, fieldNumber: 5)
    }
    if !self.thumbnailSizes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.thumbnailSizes, fieldNumber: 6)
    }
    if !self.selectedSlideNodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.selectedSlideNodes, fieldNumber: 7)
    }
    if !self.restoreSelectedSlideNodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.restoreSelectedSlideNodes, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_UIStateCommandGroupArchive, rhs: KN_UIStateCommandGroupArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._uiState != rhs._uiState {return false}
    if lhs._property != rhs._property {return false}
    if lhs.slideNodesToEdit != rhs.slideNodesToEdit {return false}
    if lhs.masterSlideNodesToApply != rhs.masterSlideNodesToApply {return false}
    if lhs.thumbnailSizes != rhs.thumbnailSizes {return false}
    if lhs.selectedSlideNodes != rhs.selectedSlideNodes {return false}
    if lhs.restoreSelectedSlideNodes != rhs.restoreSelectedSlideNodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideInsertDrawablesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideInsertDrawablesArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "slide_id"),
    3: .same(proto: "drawables"),
    18: .standard(proto: "working_drawables"),
    4: .standard(proto: "args_list"),
    5: .standard(proto: "update_geometry_to_match_object_placeholder"),
    6: .standard(proto: "ids_of_drawables_using_object_placeholder_geometry"),
    7: .standard(proto: "sage_placeholder_tags_list"),
    20: .standard(proto: "instructional_text_list"),
    8: .standard(proto: "undo_archive"),
    9: .standard(proto: "is_pasting"),
    10: .standard(proto: "insert_build_descriptions"),
    19: .standard(proto: "working_insert_build_descriptions"),
    11: .standard(proto: "remove_build_descriptions"),
    12: .standard(proto: "remove_slide_specific_hyperlinks"),
    13: .standard(proto: "custom_format_keys"),
    16: .standard(proto: "saved_next_untitled_resolver_index"),
    17: .standard(proto: "geometry_of_object_placeholder_for_comparison_to_restore_link"),
  ]

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _slideID: TSP_UUID? = nil
    var _drawables: [TSP_Reference] = []
    var _workingDrawables: [TSP_Reference] = []
    var _argsList: KN_MixedIdOperationArgs? = nil
    var _updateGeometryToMatchObjectPlaceholder: Bool? = nil
    var _idsOfDrawablesUsingObjectPlaceholderGeometry: [TSP_UUID] = []
    var _sagePlaceholderTagsList: [String] = []
    var _instructionalTextList: [String] = []
    var _undoArchive: TSP_Reference? = nil
    var _isPasting: Bool? = nil
    var _insertBuildDescriptions: [TSP_Reference] = []
    var _workingInsertBuildDescriptions: [TSP_Reference] = []
    var _removeBuildDescriptions: [TSP_Reference] = []
    var _removeSlideSpecificHyperlinks: Bool? = nil
    var _customFormatKeys: [TSP_UUID] = []
    var _savedNextUntitledResolverIndex: UInt32? = nil
    var _geometryOfObjectPlaceholderForComparisonToRestoreLink: TSD_GeometryArchive? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _slideID = source._slideID
      _drawables = source._drawables
      _workingDrawables = source._workingDrawables
      _argsList = source._argsList
      _updateGeometryToMatchObjectPlaceholder = source._updateGeometryToMatchObjectPlaceholder
      _idsOfDrawablesUsingObjectPlaceholderGeometry = source._idsOfDrawablesUsingObjectPlaceholderGeometry
      _sagePlaceholderTagsList = source._sagePlaceholderTagsList
      _instructionalTextList = source._instructionalTextList
      _undoArchive = source._undoArchive
      _isPasting = source._isPasting
      _insertBuildDescriptions = source._insertBuildDescriptions
      _workingInsertBuildDescriptions = source._workingInsertBuildDescriptions
      _removeBuildDescriptions = source._removeBuildDescriptions
      _removeSlideSpecificHyperlinks = source._removeSlideSpecificHyperlinks
      _customFormatKeys = source._customFormatKeys
      _savedNextUntitledResolverIndex = source._savedNextUntitledResolverIndex
      _geometryOfObjectPlaceholderForComparisonToRestoreLink = source._geometryOfObjectPlaceholderForComparisonToRestoreLink
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._slideID == nil {return false}
      if _storage._updateGeometryToMatchObjectPlaceholder == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._slideID, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._drawables) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._workingDrawables) {return false}
      if let v = _storage._argsList, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._idsOfDrawablesUsingObjectPlaceholderGeometry) {return false}
      if let v = _storage._undoArchive, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._insertBuildDescriptions) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._workingInsertBuildDescriptions) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._removeBuildDescriptions) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._customFormatKeys) {return false}
      if let v = _storage._geometryOfObjectPlaceholderForComparisonToRestoreLink, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._super)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._slideID)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._drawables)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._argsList)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._updateGeometryToMatchObjectPlaceholder)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._idsOfDrawablesUsingObjectPlaceholderGeometry)
        case 7: try decoder.decodeRepeatedStringField(value: &_storage._sagePlaceholderTagsList)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._undoArchive)
        case 9: try decoder.decodeSingularBoolField(value: &_storage._isPasting)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._insertBuildDescriptions)
        case 11: try decoder.decodeRepeatedMessageField(value: &_storage._removeBuildDescriptions)
        case 12: try decoder.decodeSingularBoolField(value: &_storage._removeSlideSpecificHyperlinks)
        case 13: try decoder.decodeRepeatedMessageField(value: &_storage._customFormatKeys)
        case 16: try decoder.decodeSingularUInt32Field(value: &_storage._savedNextUntitledResolverIndex)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._geometryOfObjectPlaceholderForComparisonToRestoreLink)
        case 18: try decoder.decodeRepeatedMessageField(value: &_storage._workingDrawables)
        case 19: try decoder.decodeRepeatedMessageField(value: &_storage._workingInsertBuildDescriptions)
        case 20: try decoder.decodeRepeatedStringField(value: &_storage._instructionalTextList)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._slideID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._drawables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._drawables, fieldNumber: 3)
      }
      if let v = _storage._argsList {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._updateGeometryToMatchObjectPlaceholder {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      }
      if !_storage._idsOfDrawablesUsingObjectPlaceholderGeometry.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._idsOfDrawablesUsingObjectPlaceholderGeometry, fieldNumber: 6)
      }
      if !_storage._sagePlaceholderTagsList.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._sagePlaceholderTagsList, fieldNumber: 7)
      }
      if let v = _storage._undoArchive {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._isPasting {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      }
      if !_storage._insertBuildDescriptions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._insertBuildDescriptions, fieldNumber: 10)
      }
      if !_storage._removeBuildDescriptions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._removeBuildDescriptions, fieldNumber: 11)
      }
      if let v = _storage._removeSlideSpecificHyperlinks {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      }
      if !_storage._customFormatKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._customFormatKeys, fieldNumber: 13)
      }
      if let v = _storage._savedNextUntitledResolverIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 16)
      }
      if let v = _storage._geometryOfObjectPlaceholderForComparisonToRestoreLink {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if !_storage._workingDrawables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._workingDrawables, fieldNumber: 18)
      }
      if !_storage._workingInsertBuildDescriptions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._workingInsertBuildDescriptions, fieldNumber: 19)
      }
      if !_storage._instructionalTextList.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._instructionalTextList, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideInsertDrawablesArchive, rhs: KN_CommandSlideInsertDrawablesArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._slideID != rhs_storage._slideID {return false}
        if _storage._drawables != rhs_storage._drawables {return false}
        if _storage._workingDrawables != rhs_storage._workingDrawables {return false}
        if _storage._argsList != rhs_storage._argsList {return false}
        if _storage._updateGeometryToMatchObjectPlaceholder != rhs_storage._updateGeometryToMatchObjectPlaceholder {return false}
        if _storage._idsOfDrawablesUsingObjectPlaceholderGeometry != rhs_storage._idsOfDrawablesUsingObjectPlaceholderGeometry {return false}
        if _storage._sagePlaceholderTagsList != rhs_storage._sagePlaceholderTagsList {return false}
        if _storage._instructionalTextList != rhs_storage._instructionalTextList {return false}
        if _storage._undoArchive != rhs_storage._undoArchive {return false}
        if _storage._isPasting != rhs_storage._isPasting {return false}
        if _storage._insertBuildDescriptions != rhs_storage._insertBuildDescriptions {return false}
        if _storage._workingInsertBuildDescriptions != rhs_storage._workingInsertBuildDescriptions {return false}
        if _storage._removeBuildDescriptions != rhs_storage._removeBuildDescriptions {return false}
        if _storage._removeSlideSpecificHyperlinks != rhs_storage._removeSlideSpecificHyperlinks {return false}
        if _storage._customFormatKeys != rhs_storage._customFormatKeys {return false}
        if _storage._savedNextUntitledResolverIndex != rhs_storage._savedNextUntitledResolverIndex {return false}
        if _storage._geometryOfObjectPlaceholderForComparisonToRestoreLink != rhs_storage._geometryOfObjectPlaceholderForComparisonToRestoreLink {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideSetPlaceholdersForTagsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideSetPlaceholdersForTagsArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "slide_id"),
    3: .same(proto: "infos"),
    4: .same(proto: "tags"),
    6: .standard(proto: "old_infos"),
    5: .standard(proto: "old_tags"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideID == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._slideID, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.infos) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldInfos) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._slideID)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.infos)
      case 4: try decoder.decodeRepeatedStringField(value: &self.tags)
      case 5: try decoder.decodeRepeatedStringField(value: &self.oldTags)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.oldInfos)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._slideID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.infos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infos, fieldNumber: 3)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 4)
    }
    if !self.oldTags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.oldTags, fieldNumber: 5)
    }
    if !self.oldInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldInfos, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideSetPlaceholdersForTagsArchive, rhs: KN_CommandSlideSetPlaceholdersForTagsArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideID != rhs._slideID {return false}
    if lhs.infos != rhs.infos {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.oldInfos != rhs.oldInfos {return false}
    if lhs.oldTags != rhs.oldTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandMasterSlideSetPlaceholderForTagArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandMasterSlideSetPlaceholderForTagArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "placeholder_id"),
    3: .same(proto: "tag"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._placeholderID == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._placeholderID, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._placeholderID)
      case 3: try decoder.decodeSingularStringField(value: &self._tag)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._placeholderID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._tag {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandMasterSlideSetPlaceholderForTagArchive, rhs: KN_CommandMasterSlideSetPlaceholderForTagArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._placeholderID != rhs._placeholderID {return false}
    if lhs._tag != rhs._tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlidePropagateSetPlaceholderForTagArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlidePropagateSetPlaceholderForTagArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "placeholder_id"),
    3: .standard(proto: "original_id"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._placeholderID == nil {return false}
    if self._originalID == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._placeholderID, !v.isInitialized {return false}
    if let v = self._originalID, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._placeholderID)
      case 3: try decoder.decodeSingularMessageField(value: &self._originalID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._placeholderID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._originalID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlidePropagateSetPlaceholderForTagArchive, rhs: KN_CommandSlidePropagateSetPlaceholderForTagArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._placeholderID != rhs._placeholderID {return false}
    if lhs._originalID != rhs._originalID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideRemoveDrawableArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideRemoveDrawableArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "slide_id"),
    3: .same(proto: "sortedDrawables"),
    4: .standard(proto: "args_list"),
    10: .standard(proto: "drawable_indexes_for_undo"),
    5: .same(proto: "placeholderTags"),
    11: .standard(proto: "instructional_text_list"),
    6: .standard(proto: "insert_build_descriptions"),
    7: .standard(proto: "remove_build_descriptions"),
    8: .standard(proto: "drawables_using_object_placeholder_geometry"),
    9: .standard(proto: "inverse_insert_hyperlink_commands"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideID == nil {return false}
    if self._argsList == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._slideID, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.sortedDrawables) {return false}
    if let v = self._argsList, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.insertBuildDescriptions) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.removeBuildDescriptions) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.drawablesUsingObjectPlaceholderGeometry) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.inverseInsertHyperlinkCommands) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._slideID)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.sortedDrawables)
      case 4: try decoder.decodeSingularMessageField(value: &self._argsList)
      case 5: try decoder.decodeRepeatedStringField(value: &self.placeholderTags)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.insertBuildDescriptions)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.removeBuildDescriptions)
      case 8: try decoder.decodeRepeatedMessageField(value: &self.drawablesUsingObjectPlaceholderGeometry)
      case 9: try decoder.decodeRepeatedMessageField(value: &self.inverseInsertHyperlinkCommands)
      case 10: try decoder.decodeRepeatedUInt32Field(value: &self.drawableIndexesForUndo)
      case 11: try decoder.decodeRepeatedStringField(value: &self.instructionalTextList)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._slideID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.sortedDrawables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sortedDrawables, fieldNumber: 3)
    }
    if let v = self._argsList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.placeholderTags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.placeholderTags, fieldNumber: 5)
    }
    if !self.insertBuildDescriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.insertBuildDescriptions, fieldNumber: 6)
    }
    if !self.removeBuildDescriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.removeBuildDescriptions, fieldNumber: 7)
    }
    if !self.drawablesUsingObjectPlaceholderGeometry.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.drawablesUsingObjectPlaceholderGeometry, fieldNumber: 8)
    }
    if !self.inverseInsertHyperlinkCommands.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inverseInsertHyperlinkCommands, fieldNumber: 9)
    }
    if !self.drawableIndexesForUndo.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.drawableIndexesForUndo, fieldNumber: 10)
    }
    if !self.instructionalTextList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.instructionalTextList, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideRemoveDrawableArchive, rhs: KN_CommandSlideRemoveDrawableArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideID != rhs._slideID {return false}
    if lhs.sortedDrawables != rhs.sortedDrawables {return false}
    if lhs._argsList != rhs._argsList {return false}
    if lhs.drawableIndexesForUndo != rhs.drawableIndexesForUndo {return false}
    if lhs.placeholderTags != rhs.placeholderTags {return false}
    if lhs.instructionalTextList != rhs.instructionalTextList {return false}
    if lhs.insertBuildDescriptions != rhs.insertBuildDescriptions {return false}
    if lhs.removeBuildDescriptions != rhs.removeBuildDescriptions {return false}
    if lhs.drawablesUsingObjectPlaceholderGeometry != rhs.drawablesUsingObjectPlaceholderGeometry {return false}
    if lhs.inverseInsertHyperlinkCommands != rhs.inverseInsertHyperlinkCommands {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideMoveDrawableZOrderArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideMoveDrawableZOrderArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    4: .standard(proto: "old_ordered_infos"),
    6: .standard(proto: "args_list"),
    7: .standard(proto: "slide_id"),
    8: .standard(proto: "old_ordered_infos_on_slide_for_undo"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideID == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldOrderedInfos) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.argsList) {return false}
    if let v = self._slideID, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldOrderedInfosOnSlideForUndo) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.oldOrderedInfos)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.argsList)
      case 7: try decoder.decodeSingularMessageField(value: &self._slideID)
      case 8: try decoder.decodeRepeatedMessageField(value: &self.oldOrderedInfosOnSlideForUndo)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.oldOrderedInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldOrderedInfos, fieldNumber: 4)
    }
    if !self.argsList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.argsList, fieldNumber: 6)
    }
    if let v = self._slideID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.oldOrderedInfosOnSlideForUndo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldOrderedInfosOnSlideForUndo, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideMoveDrawableZOrderArchive, rhs: KN_CommandSlideMoveDrawableZOrderArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.oldOrderedInfos != rhs.oldOrderedInfos {return false}
    if lhs.argsList != rhs.argsList {return false}
    if lhs._slideID != rhs._slideID {return false}
    if lhs.oldOrderedInfosOnSlideForUndo != rhs.oldOrderedInfosOnSlideForUndo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideNodeSetPropertyArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideNodeSetPropertyArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "slide_node_id_path"),
    3: .same(proto: "property"),
    4: .standard(proto: "old_value"),
    5: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideNodeIDPath == nil {return false}
    if self._property == nil {return false}
    if self._oldValue == nil {return false}
    if self._value == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._slideNodeIDPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._slideNodeIDPath)
      case 3: try decoder.decodeSingularStringField(value: &self._property)
      case 4: try decoder.decodeSingularBoolField(value: &self._oldValue)
      case 5: try decoder.decodeSingularBoolField(value: &self._value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._slideNodeIDPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._property {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._oldValue {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if let v = self._value {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideNodeSetPropertyArchive, rhs: KN_CommandSlideNodeSetPropertyArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideNodeIDPath != rhs._slideNodeIDPath {return false}
    if lhs._property != rhs._property {return false}
    if lhs._oldValue != rhs._oldValue {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideNodeSetViewStatePropertyArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideNodeSetViewStatePropertyArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "slide_node_id_path"),
    3: .same(proto: "property"),
    4: .standard(proto: "old_value"),
    5: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideNodeIDPath == nil {return false}
    if self._property == nil {return false}
    if self._oldValue == nil {return false}
    if self._value == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._slideNodeIDPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._slideNodeIDPath)
      case 3: try decoder.decodeSingularStringField(value: &self._property)
      case 4: try decoder.decodeSingularBoolField(value: &self._oldValue)
      case 5: try decoder.decodeSingularBoolField(value: &self._value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._slideNodeIDPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._property {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._oldValue {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if let v = self._value {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideNodeSetViewStatePropertyArchive, rhs: KN_CommandSlideNodeSetViewStatePropertyArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideNodeIDPath != rhs._slideNodeIDPath {return false}
    if lhs._property != rhs._property {return false}
    if lhs._oldValue != rhs._oldValue {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideSetBackgroundFillArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideSetBackgroundFillArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "slide_id_path"),
    3: .standard(proto: "old_fill"),
    4: .standard(proto: "new_fill"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideIDPath == nil {return false}
    if self._newFill == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._slideIDPath, !v.isInitialized {return false}
    if let v = self._oldFill, !v.isInitialized {return false}
    if let v = self._newFill, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._slideIDPath)
      case 3: try decoder.decodeSingularMessageField(value: &self._oldFill)
      case 4: try decoder.decodeSingularMessageField(value: &self._newFill)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._slideIDPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._oldFill {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._newFill {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideSetBackgroundFillArchive, rhs: KN_CommandSlideSetBackgroundFillArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideIDPath != rhs._slideIDPath {return false}
    if lhs._oldFill != rhs._oldFill {return false}
    if lhs._newFill != rhs._newFill {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideSetStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideSetStyleArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "slide_id_path"),
    3: .standard(proto: "slide_style"),
    4: .standard(proto: "old_slide_style"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideIDPath == nil {return false}
    if self._slideStyle == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._slideIDPath, !v.isInitialized {return false}
    if let v = self._slideStyle, !v.isInitialized {return false}
    if let v = self._oldSlideStyle, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._slideIDPath)
      case 3: try decoder.decodeSingularMessageField(value: &self._slideStyle)
      case 4: try decoder.decodeSingularMessageField(value: &self._oldSlideStyle)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._slideIDPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._slideStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._oldSlideStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideSetStyleArchive, rhs: KN_CommandSlideSetStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideIDPath != rhs._slideIDPath {return false}
    if lhs._slideStyle != rhs._slideStyle {return false}
    if lhs._oldSlideStyle != rhs._oldSlideStyle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowMarkOutOfSyncRecordingArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowMarkOutOfSyncRecordingArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .same(proto: "show"),
    3: .standard(proto: "old_recording"),
    4: .standard(proto: "old_is_recording_out_of_sync"),
    5: .standard(proto: "new_is_recording_out_of_sync"),
    6: .standard(proto: "old_modification_date"),
    7: .standard(proto: "new_modification_date"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._show == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._show, !v.isInitialized {return false}
    if let v = self._oldRecording, !v.isInitialized {return false}
    if let v = self._oldModificationDate, !v.isInitialized {return false}
    if let v = self._newModificationDate, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._show)
      case 3: try decoder.decodeSingularMessageField(value: &self._oldRecording)
      case 4: try decoder.decodeSingularBoolField(value: &self._oldIsRecordingOutOfSync)
      case 5: try decoder.decodeSingularBoolField(value: &self._newIsRecordingOutOfSync)
      case 6: try decoder.decodeSingularMessageField(value: &self._oldModificationDate)
      case 7: try decoder.decodeSingularMessageField(value: &self._newModificationDate)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._show {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._oldRecording {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._oldIsRecordingOutOfSync {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if let v = self._newIsRecordingOutOfSync {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    if let v = self._oldModificationDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._newModificationDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowMarkOutOfSyncRecordingArchive, rhs: KN_CommandShowMarkOutOfSyncRecordingArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._show != rhs._show {return false}
    if lhs._oldRecording != rhs._oldRecording {return false}
    if lhs._oldIsRecordingOutOfSync != rhs._oldIsRecordingOutOfSync {return false}
    if lhs._newIsRecordingOutOfSync != rhs._newIsRecordingOutOfSync {return false}
    if lhs._oldModificationDate != rhs._oldModificationDate {return false}
    if lhs._newModificationDate != rhs._newModificationDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowMarkOutOfSyncRecordingIfNeededArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowMarkOutOfSyncRecordingIfNeededArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "out_of_sync_token"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._outOfSyncToken, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._outOfSyncToken)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._outOfSyncToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowMarkOutOfSyncRecordingIfNeededArchive, rhs: KN_CommandShowMarkOutOfSyncRecordingIfNeededArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._outOfSyncToken != rhs._outOfSyncToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowRemoveRecordingArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowRemoveRecordingArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .same(proto: "show"),
    3: .standard(proto: "old_recording"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._show == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._show, !v.isInitialized {return false}
    if let v = self._oldRecording, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._show)
      case 3: try decoder.decodeSingularMessageField(value: &self._oldRecording)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._show {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._oldRecording {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowRemoveRecordingArchive, rhs: KN_CommandShowRemoveRecordingArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._show != rhs._show {return false}
    if lhs._oldRecording != rhs._oldRecording {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowReplaceRecordingArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowReplaceRecordingArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .same(proto: "show"),
    3: .standard(proto: "replacement_recording"),
    5: .standard(proto: "old_recording"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._show == nil {return false}
    if self._replacementRecording == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._show, !v.isInitialized {return false}
    if let v = self._replacementRecording, !v.isInitialized {return false}
    if let v = self._oldRecording, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._show)
      case 3: try decoder.decodeSingularMessageField(value: &self._replacementRecording)
      case 5: try decoder.decodeSingularMessageField(value: &self._oldRecording)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._show {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._replacementRecording {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._oldRecording {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowReplaceRecordingArchive, rhs: KN_CommandShowReplaceRecordingArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._show != rhs._show {return false}
    if lhs._replacementRecording != rhs._replacementRecording {return false}
    if lhs._oldRecording != rhs._oldRecording {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowSetValueArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowSetValueArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .same(proto: "show"),
    3: .same(proto: "property"),
    4: .standard(proto: "old_value"),
    5: .standard(proto: "new_value"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._show == nil {return false}
    if self._property == nil {return false}
    if self._oldValue == nil {return false}
    if self._newValue == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._show, !v.isInitialized {return false}
    if let v = self._oldValue, !v.isInitialized {return false}
    if let v = self._newValue, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._show)
      case 3: try decoder.decodeSingularStringField(value: &self._property)
      case 4: try decoder.decodeSingularMessageField(value: &self._oldValue)
      case 5: try decoder.decodeSingularMessageField(value: &self._newValue)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._show {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._property {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._oldValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._newValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowSetValueArchive, rhs: KN_CommandShowSetValueArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._show != rhs._show {return false}
    if lhs._property != rhs._property {return false}
    if lhs._oldValue != rhs._oldValue {return false}
    if lhs._newValue != rhs._newValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowSetValueArchive.PropertyValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = KN_CommandShowSetValueArchive.protoMessageName + ".PropertyValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bool_value"),
    2: .standard(proto: "double_value"),
    3: .standard(proto: "show_mode_value"),
    4: .standard(proto: "size_value"),
  ]

  public var isInitialized: Bool {
    if let v = self._sizeValue, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self._boolValue)
      case 2: try decoder.decodeSingularDoubleField(value: &self._doubleValue)
      case 3: try decoder.decodeSingularEnumField(value: &self._showModeValue)
      case 4: try decoder.decodeSingularMessageField(value: &self._sizeValue)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._boolValue {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._doubleValue {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    }
    if let v = self._showModeValue {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    if let v = self._sizeValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowSetValueArchive.PropertyValue, rhs: KN_CommandShowSetValueArchive.PropertyValue) -> Bool {
    if lhs._boolValue != rhs._boolValue {return false}
    if lhs._doubleValue != rhs._doubleValue {return false}
    if lhs._showModeValue != rhs._showModeValue {return false}
    if lhs._sizeValue != rhs._sizeValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowInsertSlideArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowInsertSlideArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "slide_nodes_being_inserted"),
    14: .standard(proto: "working_slide_nodes_being_inserted"),
    3: .standard(proto: "inserted_args_list"),
    4: .standard(proto: "ids_of_slide_nodes_with_depth_changes"),
    5: .standard(proto: "depths_of_slide_nodes_with_depth_changes"),
    6: .standard(proto: "old_depths_of_slide_nodes_with_depth_changes"),
    7: .standard(proto: "slide_nodes_for_depth_fix_up"),
    8: .standard(proto: "depths_of_slide_nodes_for_depth_fix_up"),
    9: .standard(proto: "old_depths_of_slide_nodes_for_depth_fix_up"),
    10: .same(proto: "kind"),
    11: .standard(proto: "master_nodes_being_inserted"),
    12: .standard(proto: "custom_format_keys"),
    13: .standard(proto: "collapsed_state_of_slide_nodes_being_inserted"),
    15: .standard(proto: "undo_archive"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.slideNodesBeingInserted) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.workingSlideNodesBeingInserted) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.insertedArgsList) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.idsOfSlideNodesWithDepthChanges) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.slideNodesForDepthFixUp) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.masterNodesBeingInserted) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.customFormatKeys) {return false}
    if let v = self._undoArchive, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.slideNodesBeingInserted)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.insertedArgsList)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.idsOfSlideNodesWithDepthChanges)
      case 5: try decoder.decodeRepeatedUInt32Field(value: &self.depthsOfSlideNodesWithDepthChanges)
      case 6: try decoder.decodeRepeatedUInt32Field(value: &self.oldDepthsOfSlideNodesWithDepthChanges)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.slideNodesForDepthFixUp)
      case 8: try decoder.decodeRepeatedUInt32Field(value: &self.depthsOfSlideNodesForDepthFixUp)
      case 9: try decoder.decodeRepeatedUInt32Field(value: &self.oldDepthsOfSlideNodesForDepthFixUp)
      case 10: try decoder.decodeSingularEnumField(value: &self._kind)
      case 11: try decoder.decodeRepeatedMessageField(value: &self.masterNodesBeingInserted)
      case 12: try decoder.decodeRepeatedMessageField(value: &self.customFormatKeys)
      case 13: try decoder.decodeRepeatedBoolField(value: &self.collapsedStateOfSlideNodesBeingInserted)
      case 14: try decoder.decodeRepeatedMessageField(value: &self.workingSlideNodesBeingInserted)
      case 15: try decoder.decodeSingularMessageField(value: &self._undoArchive)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.slideNodesBeingInserted.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.slideNodesBeingInserted, fieldNumber: 2)
    }
    if !self.insertedArgsList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.insertedArgsList, fieldNumber: 3)
    }
    if !self.idsOfSlideNodesWithDepthChanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.idsOfSlideNodesWithDepthChanges, fieldNumber: 4)
    }
    if !self.depthsOfSlideNodesWithDepthChanges.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.depthsOfSlideNodesWithDepthChanges, fieldNumber: 5)
    }
    if !self.oldDepthsOfSlideNodesWithDepthChanges.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.oldDepthsOfSlideNodesWithDepthChanges, fieldNumber: 6)
    }
    if !self.slideNodesForDepthFixUp.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.slideNodesForDepthFixUp, fieldNumber: 7)
    }
    if !self.depthsOfSlideNodesForDepthFixUp.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.depthsOfSlideNodesForDepthFixUp, fieldNumber: 8)
    }
    if !self.oldDepthsOfSlideNodesForDepthFixUp.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.oldDepthsOfSlideNodesForDepthFixUp, fieldNumber: 9)
    }
    if let v = self._kind {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
    }
    if !self.masterNodesBeingInserted.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.masterNodesBeingInserted, fieldNumber: 11)
    }
    if !self.customFormatKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customFormatKeys, fieldNumber: 12)
    }
    if !self.collapsedStateOfSlideNodesBeingInserted.isEmpty {
      try visitor.visitRepeatedBoolField(value: self.collapsedStateOfSlideNodesBeingInserted, fieldNumber: 13)
    }
    if !self.workingSlideNodesBeingInserted.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workingSlideNodesBeingInserted, fieldNumber: 14)
    }
    if let v = self._undoArchive {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowInsertSlideArchive, rhs: KN_CommandShowInsertSlideArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.slideNodesBeingInserted != rhs.slideNodesBeingInserted {return false}
    if lhs.workingSlideNodesBeingInserted != rhs.workingSlideNodesBeingInserted {return false}
    if lhs.insertedArgsList != rhs.insertedArgsList {return false}
    if lhs.idsOfSlideNodesWithDepthChanges != rhs.idsOfSlideNodesWithDepthChanges {return false}
    if lhs.depthsOfSlideNodesWithDepthChanges != rhs.depthsOfSlideNodesWithDepthChanges {return false}
    if lhs.oldDepthsOfSlideNodesWithDepthChanges != rhs.oldDepthsOfSlideNodesWithDepthChanges {return false}
    if lhs.slideNodesForDepthFixUp != rhs.slideNodesForDepthFixUp {return false}
    if lhs.depthsOfSlideNodesForDepthFixUp != rhs.depthsOfSlideNodesForDepthFixUp {return false}
    if lhs.oldDepthsOfSlideNodesForDepthFixUp != rhs.oldDepthsOfSlideNodesForDepthFixUp {return false}
    if lhs._kind != rhs._kind {return false}
    if lhs.masterNodesBeingInserted != rhs.masterNodesBeingInserted {return false}
    if lhs.customFormatKeys != rhs.customFormatKeys {return false}
    if lhs.collapsedStateOfSlideNodesBeingInserted != rhs.collapsedStateOfSlideNodesBeingInserted {return false}
    if lhs._undoArchive != rhs._undoArchive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowInsertSlideArchive.Kind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "kKindInsertSlide"),
    1: .same(proto: "kKindInsertSlideForPaste"),
    2: .same(proto: "kKindInsertSlideForDuplicate"),
  ]
}

extension KN_CommandShowMoveSlideArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowMoveSlideArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "slide_nodes_being_moved_linearly"),
    3: .standard(proto: "rearranged_args_list"),
    4: .standard(proto: "ids_of_slide_nodes_with_depth_changes"),
    5: .standard(proto: "depths_of_slide_nodes_with_depth_changes"),
    6: .standard(proto: "old_depths_of_slide_nodes_with_depth_changes"),
    7: .standard(proto: "slide_nodes_for_depth_fix_up"),
    8: .standard(proto: "depths_of_slide_nodes_for_depth_fix_up"),
    9: .standard(proto: "old_depths_of_slide_nodes_for_depth_fix_up"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.slideNodesBeingMovedLinearly) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rearrangedArgsList) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.idsOfSlideNodesWithDepthChanges) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.slideNodesForDepthFixUp) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.slideNodesBeingMovedLinearly)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.rearrangedArgsList)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.idsOfSlideNodesWithDepthChanges)
      case 5: try decoder.decodeRepeatedUInt32Field(value: &self.depthsOfSlideNodesWithDepthChanges)
      case 6: try decoder.decodeRepeatedUInt32Field(value: &self.oldDepthsOfSlideNodesWithDepthChanges)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.slideNodesForDepthFixUp)
      case 8: try decoder.decodeRepeatedUInt32Field(value: &self.depthsOfSlideNodesForDepthFixUp)
      case 9: try decoder.decodeRepeatedUInt32Field(value: &self.oldDepthsOfSlideNodesForDepthFixUp)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.slideNodesBeingMovedLinearly.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.slideNodesBeingMovedLinearly, fieldNumber: 2)
    }
    if !self.rearrangedArgsList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rearrangedArgsList, fieldNumber: 3)
    }
    if !self.idsOfSlideNodesWithDepthChanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.idsOfSlideNodesWithDepthChanges, fieldNumber: 4)
    }
    if !self.depthsOfSlideNodesWithDepthChanges.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.depthsOfSlideNodesWithDepthChanges, fieldNumber: 5)
    }
    if !self.oldDepthsOfSlideNodesWithDepthChanges.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.oldDepthsOfSlideNodesWithDepthChanges, fieldNumber: 6)
    }
    if !self.slideNodesForDepthFixUp.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.slideNodesForDepthFixUp, fieldNumber: 7)
    }
    if !self.depthsOfSlideNodesForDepthFixUp.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.depthsOfSlideNodesForDepthFixUp, fieldNumber: 8)
    }
    if !self.oldDepthsOfSlideNodesForDepthFixUp.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.oldDepthsOfSlideNodesForDepthFixUp, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowMoveSlideArchive, rhs: KN_CommandShowMoveSlideArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.slideNodesBeingMovedLinearly != rhs.slideNodesBeingMovedLinearly {return false}
    if lhs.rearrangedArgsList != rhs.rearrangedArgsList {return false}
    if lhs.idsOfSlideNodesWithDepthChanges != rhs.idsOfSlideNodesWithDepthChanges {return false}
    if lhs.depthsOfSlideNodesWithDepthChanges != rhs.depthsOfSlideNodesWithDepthChanges {return false}
    if lhs.oldDepthsOfSlideNodesWithDepthChanges != rhs.oldDepthsOfSlideNodesWithDepthChanges {return false}
    if lhs.slideNodesForDepthFixUp != rhs.slideNodesForDepthFixUp {return false}
    if lhs.depthsOfSlideNodesForDepthFixUp != rhs.depthsOfSlideNodesForDepthFixUp {return false}
    if lhs.oldDepthsOfSlideNodesForDepthFixUp != rhs.oldDepthsOfSlideNodesForDepthFixUp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowRemoveSlideArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowRemoveSlideArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "slide_nodes_being_removed"),
    3: .standard(proto: "removed_args_list"),
    4: .standard(proto: "ids_of_slide_nodes_with_depth_changes"),
    5: .standard(proto: "depths_of_slide_nodes_with_depth_changes"),
    6: .standard(proto: "old_depths_of_slide_nodes_with_depth_changes"),
    7: .standard(proto: "slide_nodes_for_depth_fix_up"),
    8: .standard(proto: "depths_of_slide_nodes_for_depth_fix_up"),
    9: .standard(proto: "old_depths_of_slide_nodes_for_depth_fix_up"),
    11: .standard(proto: "collapsed_state_of_slide_nodes_being_removed"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.slideNodesBeingRemoved) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.removedArgsList) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.idsOfSlideNodesWithDepthChanges) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.slideNodesForDepthFixUp) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.slideNodesBeingRemoved)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.removedArgsList)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.idsOfSlideNodesWithDepthChanges)
      case 5: try decoder.decodeRepeatedUInt32Field(value: &self.depthsOfSlideNodesWithDepthChanges)
      case 6: try decoder.decodeRepeatedUInt32Field(value: &self.oldDepthsOfSlideNodesWithDepthChanges)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.slideNodesForDepthFixUp)
      case 8: try decoder.decodeRepeatedUInt32Field(value: &self.depthsOfSlideNodesForDepthFixUp)
      case 9: try decoder.decodeRepeatedUInt32Field(value: &self.oldDepthsOfSlideNodesForDepthFixUp)
      case 11: try decoder.decodeRepeatedBoolField(value: &self.collapsedStateOfSlideNodesBeingRemoved)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.slideNodesBeingRemoved.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.slideNodesBeingRemoved, fieldNumber: 2)
    }
    if !self.removedArgsList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.removedArgsList, fieldNumber: 3)
    }
    if !self.idsOfSlideNodesWithDepthChanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.idsOfSlideNodesWithDepthChanges, fieldNumber: 4)
    }
    if !self.depthsOfSlideNodesWithDepthChanges.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.depthsOfSlideNodesWithDepthChanges, fieldNumber: 5)
    }
    if !self.oldDepthsOfSlideNodesWithDepthChanges.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.oldDepthsOfSlideNodesWithDepthChanges, fieldNumber: 6)
    }
    if !self.slideNodesForDepthFixUp.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.slideNodesForDepthFixUp, fieldNumber: 7)
    }
    if !self.depthsOfSlideNodesForDepthFixUp.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.depthsOfSlideNodesForDepthFixUp, fieldNumber: 8)
    }
    if !self.oldDepthsOfSlideNodesForDepthFixUp.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.oldDepthsOfSlideNodesForDepthFixUp, fieldNumber: 9)
    }
    if !self.collapsedStateOfSlideNodesBeingRemoved.isEmpty {
      try visitor.visitRepeatedBoolField(value: self.collapsedStateOfSlideNodesBeingRemoved, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowRemoveSlideArchive, rhs: KN_CommandShowRemoveSlideArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.slideNodesBeingRemoved != rhs.slideNodesBeingRemoved {return false}
    if lhs.removedArgsList != rhs.removedArgsList {return false}
    if lhs.idsOfSlideNodesWithDepthChanges != rhs.idsOfSlideNodesWithDepthChanges {return false}
    if lhs.depthsOfSlideNodesWithDepthChanges != rhs.depthsOfSlideNodesWithDepthChanges {return false}
    if lhs.oldDepthsOfSlideNodesWithDepthChanges != rhs.oldDepthsOfSlideNodesWithDepthChanges {return false}
    if lhs.slideNodesForDepthFixUp != rhs.slideNodesForDepthFixUp {return false}
    if lhs.depthsOfSlideNodesForDepthFixUp != rhs.depthsOfSlideNodesForDepthFixUp {return false}
    if lhs.oldDepthsOfSlideNodesForDepthFixUp != rhs.oldDepthsOfSlideNodesForDepthFixUp {return false}
    if lhs.collapsedStateOfSlideNodesBeingRemoved != rhs.collapsedStateOfSlideNodesBeingRemoved {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowChangeThemeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowChangeThemeArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .same(proto: "show"),
    3: .same(proto: "theme"),
    4: .standard(proto: "old_theme"),
    5: .standard(proto: "template_identifier"),
    6: .standard(proto: "old_template_identifier"),
    7: .standard(proto: "identifier_to_style_map"),
    8: .standard(proto: "old_identifier_to_style_map"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._show == nil {return false}
    if self._theme == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._show, !v.isInitialized {return false}
    if let v = self._theme, !v.isInitialized {return false}
    if let v = self._oldTheme, !v.isInitialized {return false}
    if let v = self._identifierToStyleMap, !v.isInitialized {return false}
    if let v = self._oldIdentifierToStyleMap, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._show)
      case 3: try decoder.decodeSingularMessageField(value: &self._theme)
      case 4: try decoder.decodeSingularMessageField(value: &self._oldTheme)
      case 5: try decoder.decodeSingularStringField(value: &self._templateIdentifier)
      case 6: try decoder.decodeSingularStringField(value: &self._oldTemplateIdentifier)
      case 7: try decoder.decodeSingularMessageField(value: &self._identifierToStyleMap)
      case 8: try decoder.decodeSingularMessageField(value: &self._oldIdentifierToStyleMap)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._show {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._theme {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._oldTheme {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._templateIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._oldTemplateIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._identifierToStyleMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._oldIdentifierToStyleMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowChangeThemeArchive, rhs: KN_CommandShowChangeThemeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._show != rhs._show {return false}
    if lhs._theme != rhs._theme {return false}
    if lhs._oldTheme != rhs._oldTheme {return false}
    if lhs._templateIdentifier != rhs._templateIdentifier {return false}
    if lhs._oldTemplateIdentifier != rhs._oldTemplateIdentifier {return false}
    if lhs._identifierToStyleMap != rhs._identifierToStyleMap {return false}
    if lhs._oldIdentifierToStyleMap != rhs._oldIdentifierToStyleMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowChangeThemeArchive.IdentifierToStyleMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = KN_CommandShowChangeThemeArchive.protoMessageName + ".IdentifierToStyleMap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "styles"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.styles) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.styles)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.styles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.styles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowChangeThemeArchive.IdentifierToStyleMap, rhs: KN_CommandShowChangeThemeArchive.IdentifierToStyleMap) -> Bool {
    if lhs.styles != rhs.styles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowChangeSlideSizeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowChangeSlideSizeArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .same(proto: "size"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._size == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._size, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._size)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowChangeSlideSizeArchive, rhs: KN_CommandShowChangeSlideSizeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSetThemeCustomEffectTimingCurveArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetThemeCustomEffectTimingCurveArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .same(proto: "name"),
    3: .standard(proto: "path_source"),
    4: .standard(proto: "old_path_source"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._pathSource, !v.isInitialized {return false}
    if let v = self._oldPathSource, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularStringField(value: &self._name)
      case 3: try decoder.decodeSingularMessageField(value: &self._pathSource)
      case 4: try decoder.decodeSingularMessageField(value: &self._oldPathSource)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._pathSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._oldPathSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSetThemeCustomEffectTimingCurveArchive, rhs: KN_CommandSetThemeCustomEffectTimingCurveArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._name != rhs._name {return false}
    if lhs._pathSource != rhs._pathSource {return false}
    if lhs._oldPathSource != rhs._oldPathSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandMoveMastersArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandMoveMastersArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    3: .standard(proto: "master_slides"),
    4: .standard(proto: "previous_indexes_keys"),
    5: .standard(proto: "previous_indexes_values"),
    6: .standard(proto: "final_master_arrangement"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.masterSlides) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.previousIndexesKeys) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.finalMasterArrangement) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.masterSlides)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.previousIndexesKeys)
      case 5: try decoder.decodeRepeatedUInt32Field(value: &self.previousIndexesValues)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.finalMasterArrangement)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.masterSlides.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.masterSlides, fieldNumber: 3)
    }
    if !self.previousIndexesKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.previousIndexesKeys, fieldNumber: 4)
    }
    if !self.previousIndexesValues.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.previousIndexesValues, fieldNumber: 5)
    }
    if !self.finalMasterArrangement.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.finalMasterArrangement, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandMoveMastersArchive, rhs: KN_CommandMoveMastersArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.masterSlides != rhs.masterSlides {return false}
    if lhs.previousIndexesKeys != rhs.previousIndexesKeys {return false}
    if lhs.previousIndexesValues != rhs.previousIndexesValues {return false}
    if lhs.finalMasterArrangement != rhs.finalMasterArrangement {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandInsertMasterArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandInsertMasterArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    7: .standard(proto: "undo_master_change_commands"),
    8: .standard(proto: "set_inserted_slide_as_default_master_slide"),
    9: .standard(proto: "undo_replacement_master_slide_node"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._setInsertedSlideAsDefaultMasterSlide == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.undoMasterChangeCommands) {return false}
    if let v = self._undoReplacementMasterSlideNode, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.undoMasterChangeCommands)
      case 8: try decoder.decodeSingularBoolField(value: &self._setInsertedSlideAsDefaultMasterSlide)
      case 9: try decoder.decodeSingularMessageField(value: &self._undoReplacementMasterSlideNode)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.undoMasterChangeCommands.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.undoMasterChangeCommands, fieldNumber: 7)
    }
    if let v = self._setInsertedSlideAsDefaultMasterSlide {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }
    if let v = self._undoReplacementMasterSlideNode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandInsertMasterArchive, rhs: KN_CommandInsertMasterArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.undoMasterChangeCommands != rhs.undoMasterChangeCommands {return false}
    if lhs._setInsertedSlideAsDefaultMasterSlide != rhs._setInsertedSlideAsDefaultMasterSlide {return false}
    if lhs._undoReplacementMasterSlideNode != rhs._undoReplacementMasterSlideNode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandPrimitiveInsertMasterArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandPrimitiveInsertMasterArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "was_inserted_with_drop"),
    3: .standard(proto: "custom_format_keys"),
    4: .standard(proto: "previous_classic_theme_records"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._wasInsertedWithDrop == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.customFormatKeys) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.previousClassicThemeRecords) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularBoolField(value: &self._wasInsertedWithDrop)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.customFormatKeys)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.previousClassicThemeRecords)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._wasInsertedWithDrop {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if !self.customFormatKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customFormatKeys, fieldNumber: 3)
    }
    if !self.previousClassicThemeRecords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.previousClassicThemeRecords, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandPrimitiveInsertMasterArchive, rhs: KN_CommandPrimitiveInsertMasterArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._wasInsertedWithDrop != rhs._wasInsertedWithDrop {return false}
    if lhs.customFormatKeys != rhs.customFormatKeys {return false}
    if lhs.previousClassicThemeRecords != rhs.previousClassicThemeRecords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandRemoveMasterArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRemoveMasterArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    5: .standard(proto: "replacement_master_slide_node"),
    6: .standard(proto: "master_change_commands"),
    7: .standard(proto: "default_master_slide_node_was_replaced"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._replacementMasterSlideNode, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.masterChangeCommands) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 5: try decoder.decodeSingularMessageField(value: &self._replacementMasterSlideNode)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.masterChangeCommands)
      case 7: try decoder.decodeSingularBoolField(value: &self._defaultMasterSlideNodeWasReplaced)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._replacementMasterSlideNode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.masterChangeCommands.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.masterChangeCommands, fieldNumber: 6)
    }
    if let v = self._defaultMasterSlideNodeWasReplaced {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandRemoveMasterArchive, rhs: KN_CommandRemoveMasterArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._replacementMasterSlideNode != rhs._replacementMasterSlideNode {return false}
    if lhs.masterChangeCommands != rhs.masterChangeCommands {return false}
    if lhs._defaultMasterSlideNodeWasReplaced != rhs._defaultMasterSlideNodeWasReplaced {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandPrimitiveRemoveMasterArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandPrimitiveRemoveMasterArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    3: .standard(proto: "previous_classic_theme_records"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.previousClassicThemeRecords) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.previousClassicThemeRecords)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.previousClassicThemeRecords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.previousClassicThemeRecords, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandPrimitiveRemoveMasterArchive, rhs: KN_CommandPrimitiveRemoveMasterArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.previousClassicThemeRecords != rhs.previousClassicThemeRecords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideInsertBuildArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideInsertBuildArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "insert_build_description"),
    3: .standard(proto: "identifier_for_chunk_to_insert_after"),
    4: .standard(proto: "should_create_chunks"),
    5: .standard(proto: "old_tuples_to_update"),
    6: .standard(proto: "was_initialized_over_the_wire"),
    7: .standard(proto: "has_been_committed"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._insertBuildDescription == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._insertBuildDescription, !v.isInitialized {return false}
    if let v = self._identifierForChunkToInsertAfter, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldTuplesToUpdate) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._insertBuildDescription)
      case 3: try decoder.decodeSingularMessageField(value: &self._identifierForChunkToInsertAfter)
      case 4: try decoder.decodeSingularBoolField(value: &self._shouldCreateChunks)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.oldTuplesToUpdate)
      case 6: try decoder.decodeSingularBoolField(value: &self._wasInitializedOverTheWire)
      case 7: try decoder.decodeSingularBoolField(value: &self._hasBeenCommitted_p)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._insertBuildDescription {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._identifierForChunkToInsertAfter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._shouldCreateChunks {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if !self.oldTuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldTuplesToUpdate, fieldNumber: 5)
    }
    if let v = self._wasInitializedOverTheWire {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }
    if let v = self._hasBeenCommitted_p {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideInsertBuildArchive, rhs: KN_CommandSlideInsertBuildArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._insertBuildDescription != rhs._insertBuildDescription {return false}
    if lhs._identifierForChunkToInsertAfter != rhs._identifierForChunkToInsertAfter {return false}
    if lhs._shouldCreateChunks != rhs._shouldCreateChunks {return false}
    if lhs.oldTuplesToUpdate != rhs.oldTuplesToUpdate {return false}
    if lhs._wasInitializedOverTheWire != rhs._wasInitializedOverTheWire {return false}
    if lhs._hasBeenCommitted_p != rhs._hasBeenCommitted_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_InsertBuildDescriptionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InsertBuildDescriptionArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "slide_id"),
    2: .standard(proto: "build_to_insert"),
    3: .standard(proto: "chunks_to_insert"),
    4: .standard(proto: "should_assign_chunk_identifiers"),
    5: .standard(proto: "identifers_for_chunks_to_insert_after"),
    6: .standard(proto: "tuples_to_update"),
    7: .standard(proto: "fallback_chunk_identifiers"),
    8: .standard(proto: "is_for_paste"),
  ]

  public var isInitialized: Bool {
    if self._slideID == nil {return false}
    if self._buildToInsert == nil {return false}
    if self._shouldAssignChunkIdentifiers == nil {return false}
    if self._isForPaste == nil {return false}
    if let v = self._slideID, !v.isInitialized {return false}
    if let v = self._buildToInsert, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.chunksToInsert) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.identifersForChunksToInsertAfter) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tuplesToUpdate) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.fallbackChunkIdentifiers) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._slideID)
      case 2: try decoder.decodeSingularMessageField(value: &self._buildToInsert)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.chunksToInsert)
      case 4: try decoder.decodeSingularBoolField(value: &self._shouldAssignChunkIdentifiers)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.identifersForChunksToInsertAfter)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.tuplesToUpdate)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.fallbackChunkIdentifiers)
      case 8: try decoder.decodeSingularBoolField(value: &self._isForPaste)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._slideID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._buildToInsert {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.chunksToInsert.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chunksToInsert, fieldNumber: 3)
    }
    if let v = self._shouldAssignChunkIdentifiers {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if !self.identifersForChunksToInsertAfter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identifersForChunksToInsertAfter, fieldNumber: 5)
    }
    if !self.tuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tuplesToUpdate, fieldNumber: 6)
    }
    if !self.fallbackChunkIdentifiers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fallbackChunkIdentifiers, fieldNumber: 7)
    }
    if let v = self._isForPaste {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_InsertBuildDescriptionArchive, rhs: KN_InsertBuildDescriptionArchive) -> Bool {
    if lhs._slideID != rhs._slideID {return false}
    if lhs._buildToInsert != rhs._buildToInsert {return false}
    if lhs.chunksToInsert != rhs.chunksToInsert {return false}
    if lhs._shouldAssignChunkIdentifiers != rhs._shouldAssignChunkIdentifiers {return false}
    if lhs.identifersForChunksToInsertAfter != rhs.identifersForChunksToInsertAfter {return false}
    if lhs.tuplesToUpdate != rhs.tuplesToUpdate {return false}
    if lhs.fallbackChunkIdentifiers != rhs.fallbackChunkIdentifiers {return false}
    if lhs._isForPaste != rhs._isForPaste {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_UndoObjectArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UndoObjectArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_UndoObjectArchive, rhs: KN_UndoObjectArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideRemoveBuildArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideRemoveBuildArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "remove_build_description"),
    3: .same(proto: "build"),
    4: .standard(proto: "chunks_to_insert"),
    5: .standard(proto: "identifiers_for_chunks_to_insert_after"),
    6: .standard(proto: "old_tuples_to_update"),
    7: .standard(proto: "fallback_chunk_identifiers"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._removeBuildDescription == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._removeBuildDescription, !v.isInitialized {return false}
    if let v = self._build, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.chunksToInsert) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.identifiersForChunksToInsertAfter) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldTuplesToUpdate) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.fallbackChunkIdentifiers) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._removeBuildDescription)
      case 3: try decoder.decodeSingularMessageField(value: &self._build)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.chunksToInsert)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.identifiersForChunksToInsertAfter)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.oldTuplesToUpdate)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.fallbackChunkIdentifiers)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._removeBuildDescription {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._build {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.chunksToInsert.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chunksToInsert, fieldNumber: 4)
    }
    if !self.identifiersForChunksToInsertAfter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identifiersForChunksToInsertAfter, fieldNumber: 5)
    }
    if !self.oldTuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldTuplesToUpdate, fieldNumber: 6)
    }
    if !self.fallbackChunkIdentifiers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fallbackChunkIdentifiers, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideRemoveBuildArchive, rhs: KN_CommandSlideRemoveBuildArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._removeBuildDescription != rhs._removeBuildDescription {return false}
    if lhs._build != rhs._build {return false}
    if lhs.chunksToInsert != rhs.chunksToInsert {return false}
    if lhs.identifiersForChunksToInsertAfter != rhs.identifiersForChunksToInsertAfter {return false}
    if lhs.oldTuplesToUpdate != rhs.oldTuplesToUpdate {return false}
    if lhs.fallbackChunkIdentifiers != rhs.fallbackChunkIdentifiers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_RemoveBuildDescriptionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveBuildDescriptionArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "slide_id"),
    2: .standard(proto: "build_id"),
    3: .standard(proto: "should_remove_chunks"),
    4: .standard(proto: "should_remove_chunk_identifiers"),
    5: .standard(proto: "tuples_to_update"),
  ]

  public var isInitialized: Bool {
    if let v = self._slideID, !v.isInitialized {return false}
    if let v = self._buildID, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tuplesToUpdate) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._slideID)
      case 2: try decoder.decodeSingularMessageField(value: &self._buildID)
      case 3: try decoder.decodeSingularBoolField(value: &self._shouldRemoveChunks)
      case 4: try decoder.decodeSingularBoolField(value: &self._shouldRemoveChunkIdentifiers)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.tuplesToUpdate)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._slideID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._buildID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._shouldRemoveChunks {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._shouldRemoveChunkIdentifiers {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if !self.tuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tuplesToUpdate, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_RemoveBuildDescriptionArchive, rhs: KN_RemoveBuildDescriptionArchive) -> Bool {
    if lhs._slideID != rhs._slideID {return false}
    if lhs._buildID != rhs._buildID {return false}
    if lhs._shouldRemoveChunks != rhs._shouldRemoveChunks {return false}
    if lhs._shouldRemoveChunkIdentifiers != rhs._shouldRemoveChunkIdentifiers {return false}
    if lhs.tuplesToUpdate != rhs.tuplesToUpdate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideInsertBuildChunkArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideInsertBuildChunkArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "slide_id"),
    3: .standard(proto: "chunk_to_insert"),
    4: .standard(proto: "identifier_for_chunk_to_insert_after"),
    5: .standard(proto: "tuples_to_update"),
    6: .standard(proto: "old_tuples_to_update"),
    7: .standard(proto: "needs_selection_update"),
    8: .standard(proto: "should_assign_chunk_identifier"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideID == nil {return false}
    if self._chunkToInsert == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._slideID, !v.isInitialized {return false}
    if let v = self._chunkToInsert, !v.isInitialized {return false}
    if let v = self._identifierForChunkToInsertAfter, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tuplesToUpdate) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldTuplesToUpdate) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._slideID)
      case 3: try decoder.decodeSingularMessageField(value: &self._chunkToInsert)
      case 4: try decoder.decodeSingularMessageField(value: &self._identifierForChunkToInsertAfter)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.tuplesToUpdate)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.oldTuplesToUpdate)
      case 7: try decoder.decodeSingularBoolField(value: &self._needsSelectionUpdate)
      case 8: try decoder.decodeSingularBoolField(value: &self._shouldAssignChunkIdentifier)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._slideID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._chunkToInsert {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._identifierForChunkToInsertAfter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.tuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tuplesToUpdate, fieldNumber: 5)
    }
    if !self.oldTuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldTuplesToUpdate, fieldNumber: 6)
    }
    if let v = self._needsSelectionUpdate {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    }
    if let v = self._shouldAssignChunkIdentifier {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideInsertBuildChunkArchive, rhs: KN_CommandSlideInsertBuildChunkArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideID != rhs._slideID {return false}
    if lhs._chunkToInsert != rhs._chunkToInsert {return false}
    if lhs._identifierForChunkToInsertAfter != rhs._identifierForChunkToInsertAfter {return false}
    if lhs.tuplesToUpdate != rhs.tuplesToUpdate {return false}
    if lhs.oldTuplesToUpdate != rhs.oldTuplesToUpdate {return false}
    if lhs._needsSelectionUpdate != rhs._needsSelectionUpdate {return false}
    if lhs._shouldAssignChunkIdentifier != rhs._shouldAssignChunkIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideRemoveBuildChunkArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideRemoveBuildChunkArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "slide_id"),
    3: .standard(proto: "removed_chunk"),
    4: .standard(proto: "identifier_for_chunk_to_remove"),
    5: .standard(proto: "identifier_for_chunk_to_insert_after"),
    6: .standard(proto: "tuples_to_update"),
    7: .standard(proto: "old_tuples_to_update"),
    8: .standard(proto: "needs_selection_update"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideID == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._slideID, !v.isInitialized {return false}
    if let v = self._removedChunk, !v.isInitialized {return false}
    if let v = self._identifierForChunkToRemove, !v.isInitialized {return false}
    if let v = self._identifierForChunkToInsertAfter, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tuplesToUpdate) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldTuplesToUpdate) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._slideID)
      case 3: try decoder.decodeSingularMessageField(value: &self._removedChunk)
      case 4: try decoder.decodeSingularMessageField(value: &self._identifierForChunkToRemove)
      case 5: try decoder.decodeSingularMessageField(value: &self._identifierForChunkToInsertAfter)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.tuplesToUpdate)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.oldTuplesToUpdate)
      case 8: try decoder.decodeSingularBoolField(value: &self._needsSelectionUpdate)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._slideID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._removedChunk {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._identifierForChunkToRemove {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._identifierForChunkToInsertAfter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.tuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tuplesToUpdate, fieldNumber: 6)
    }
    if !self.oldTuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldTuplesToUpdate, fieldNumber: 7)
    }
    if let v = self._needsSelectionUpdate {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideRemoveBuildChunkArchive, rhs: KN_CommandSlideRemoveBuildChunkArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideID != rhs._slideID {return false}
    if lhs._removedChunk != rhs._removedChunk {return false}
    if lhs._identifierForChunkToRemove != rhs._identifierForChunkToRemove {return false}
    if lhs._identifierForChunkToInsertAfter != rhs._identifierForChunkToInsertAfter {return false}
    if lhs.tuplesToUpdate != rhs.tuplesToUpdate {return false}
    if lhs.oldTuplesToUpdate != rhs.oldTuplesToUpdate {return false}
    if lhs._needsSelectionUpdate != rhs._needsSelectionUpdate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideMoveBuildChunksArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideMoveBuildChunksArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "identifiers_for_chunks_to_move"),
    3: .standard(proto: "identifiers_for_chunks_to_move_after"),
    4: .standard(proto: "identifiers_for_chunks_to_move_after_for_undo"),
    5: .standard(proto: "tuples_to_update"),
    6: .standard(proto: "old_tuples_to_update"),
    7: .standard(proto: "identifiers_for_chunks_to_move_including_clustered_inactive_chunks"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.identifiersForChunksToMove) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.identifiersForChunksToMoveAfter) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.identifiersForChunksToMoveAfterForUndo) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tuplesToUpdate) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldTuplesToUpdate) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.identifiersForChunksToMoveIncludingClusteredInactiveChunks) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.identifiersForChunksToMove)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.identifiersForChunksToMoveAfter)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.identifiersForChunksToMoveAfterForUndo)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.tuplesToUpdate)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.oldTuplesToUpdate)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.identifiersForChunksToMoveIncludingClusteredInactiveChunks)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.identifiersForChunksToMove.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identifiersForChunksToMove, fieldNumber: 2)
    }
    if !self.identifiersForChunksToMoveAfter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identifiersForChunksToMoveAfter, fieldNumber: 3)
    }
    if !self.identifiersForChunksToMoveAfterForUndo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identifiersForChunksToMoveAfterForUndo, fieldNumber: 4)
    }
    if !self.tuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tuplesToUpdate, fieldNumber: 5)
    }
    if !self.oldTuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldTuplesToUpdate, fieldNumber: 6)
    }
    if !self.identifiersForChunksToMoveIncludingClusteredInactiveChunks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identifiersForChunksToMoveIncludingClusteredInactiveChunks, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideMoveBuildChunksArchive, rhs: KN_CommandSlideMoveBuildChunksArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.identifiersForChunksToMove != rhs.identifiersForChunksToMove {return false}
    if lhs.identifiersForChunksToMoveAfter != rhs.identifiersForChunksToMoveAfter {return false}
    if lhs.identifiersForChunksToMoveAfterForUndo != rhs.identifiersForChunksToMoveAfterForUndo {return false}
    if lhs.tuplesToUpdate != rhs.tuplesToUpdate {return false}
    if lhs.oldTuplesToUpdate != rhs.oldTuplesToUpdate {return false}
    if lhs.identifiersForChunksToMoveIncludingClusteredInactiveChunks != rhs.identifiersForChunksToMoveIncludingClusteredInactiveChunks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandBuildSetValueArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandBuildSetValueArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .same(proto: "tuple"),
    3: .standard(proto: "chunks_to_add"),
    4: .standard(proto: "identifiers_for_chunks_to_insert_after"),
    5: .standard(proto: "identifiers_for_chunks_to_remove"),
    6: .standard(proto: "tuples_to_update"),
    7: .standard(proto: "old_tuple_for_main_property"),
    8: .standard(proto: "old_tuples_to_update_for_sub_commands"),
    9: .standard(proto: "identifiers_for_added_chunks"),
    10: .standard(proto: "generated_identifiers"),
    11: .standard(proto: "removed_chunks"),
    12: .standard(proto: "identifiers_for_chunks_prior_to_removed_chunks"),
    13: .standard(proto: "old_chunk_ID_seed"),
    14: .standard(proto: "old_chunk_identifiers"),
    15: .standard(proto: "chunks_removed_during_undo"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._tuple, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.chunksToAdd) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.identifiersForChunksToInsertAfter) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.identifiersForChunksToRemove) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tuplesToUpdate) {return false}
    if let v = self._oldTupleForMainProperty, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldTuplesToUpdateForSubCommands) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.identifiersForAddedChunks) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.generatedIdentifiers) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.removedChunks) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.identifiersForChunksPriorToRemovedChunks) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldChunkIdentifiers) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.chunksRemovedDuringUndo) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._tuple)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.chunksToAdd)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.identifiersForChunksToInsertAfter)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.identifiersForChunksToRemove)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.tuplesToUpdate)
      case 7: try decoder.decodeSingularMessageField(value: &self._oldTupleForMainProperty)
      case 8: try decoder.decodeRepeatedMessageField(value: &self.oldTuplesToUpdateForSubCommands)
      case 9: try decoder.decodeRepeatedMessageField(value: &self.identifiersForAddedChunks)
      case 10: try decoder.decodeRepeatedMessageField(value: &self.generatedIdentifiers)
      case 11: try decoder.decodeRepeatedMessageField(value: &self.removedChunks)
      case 12: try decoder.decodeRepeatedMessageField(value: &self.identifiersForChunksPriorToRemovedChunks)
      case 13: try decoder.decodeSingularUInt32Field(value: &self._oldChunkIDSeed)
      case 14: try decoder.decodeRepeatedMessageField(value: &self.oldChunkIdentifiers)
      case 15: try decoder.decodeRepeatedMessageField(value: &self.chunksRemovedDuringUndo)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._tuple {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.chunksToAdd.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chunksToAdd, fieldNumber: 3)
    }
    if !self.identifiersForChunksToInsertAfter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identifiersForChunksToInsertAfter, fieldNumber: 4)
    }
    if !self.identifiersForChunksToRemove.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identifiersForChunksToRemove, fieldNumber: 5)
    }
    if !self.tuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tuplesToUpdate, fieldNumber: 6)
    }
    if let v = self._oldTupleForMainProperty {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.oldTuplesToUpdateForSubCommands.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldTuplesToUpdateForSubCommands, fieldNumber: 8)
    }
    if !self.identifiersForAddedChunks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identifiersForAddedChunks, fieldNumber: 9)
    }
    if !self.generatedIdentifiers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.generatedIdentifiers, fieldNumber: 10)
    }
    if !self.removedChunks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.removedChunks, fieldNumber: 11)
    }
    if !self.identifiersForChunksPriorToRemovedChunks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identifiersForChunksPriorToRemovedChunks, fieldNumber: 12)
    }
    if let v = self._oldChunkIDSeed {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 13)
    }
    if !self.oldChunkIdentifiers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldChunkIdentifiers, fieldNumber: 14)
    }
    if !self.chunksRemovedDuringUndo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chunksRemovedDuringUndo, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandBuildSetValueArchive, rhs: KN_CommandBuildSetValueArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._tuple != rhs._tuple {return false}
    if lhs.chunksToAdd != rhs.chunksToAdd {return false}
    if lhs.identifiersForChunksToInsertAfter != rhs.identifiersForChunksToInsertAfter {return false}
    if lhs.identifiersForChunksToRemove != rhs.identifiersForChunksToRemove {return false}
    if lhs.tuplesToUpdate != rhs.tuplesToUpdate {return false}
    if lhs._oldTupleForMainProperty != rhs._oldTupleForMainProperty {return false}
    if lhs.oldTuplesToUpdateForSubCommands != rhs.oldTuplesToUpdateForSubCommands {return false}
    if lhs.identifiersForAddedChunks != rhs.identifiersForAddedChunks {return false}
    if lhs.generatedIdentifiers != rhs.generatedIdentifiers {return false}
    if lhs.removedChunks != rhs.removedChunks {return false}
    if lhs.identifiersForChunksPriorToRemovedChunks != rhs.identifiersForChunksPriorToRemovedChunks {return false}
    if lhs._oldChunkIDSeed != rhs._oldChunkIDSeed {return false}
    if lhs.oldChunkIdentifiers != rhs.oldChunkIdentifiers {return false}
    if lhs.chunksRemovedDuringUndo != rhs.chunksRemovedDuringUndo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandBuildUpdateChunkReferentsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandBuildUpdateChunkReferentsArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "build_id"),
    3: .standard(proto: "tuples_to_update"),
    4: .standard(proto: "old_tuples_to_update"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._buildID == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._buildID, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tuplesToUpdate) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldTuplesToUpdate) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._buildID)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.tuplesToUpdate)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.oldTuplesToUpdate)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._buildID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.tuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tuplesToUpdate, fieldNumber: 3)
    }
    if !self.oldTuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldTuplesToUpdate, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandBuildUpdateChunkReferentsArchive, rhs: KN_CommandBuildUpdateChunkReferentsArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._buildID != rhs._buildID {return false}
    if lhs.tuplesToUpdate != rhs.tuplesToUpdate {return false}
    if lhs.oldTuplesToUpdate != rhs.oldTuplesToUpdate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandBuildUpdateChunkCountArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandBuildUpdateChunkCountArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "slide_id"),
    3: .standard(proto: "drawable_ids"),
    4: .standard(proto: "expected_delivery_style_tuples"),
    5: .standard(proto: "chunks_to_add"),
    6: .standard(proto: "identifiers_for_chunks_to_insert_after"),
    7: .standard(proto: "identifiers_for_chunks_to_remove"),
    8: .standard(proto: "tuples_to_update"),
    9: .standard(proto: "needs_async_process_changes_selection_update"),
    10: .standard(proto: "old_tuples_to_update"),
    11: .standard(proto: "identifiers_for_added_chunks"),
    12: .standard(proto: "generated_identifiers"),
    13: .standard(proto: "removed_chunks"),
    14: .standard(proto: "identifiers_for_chunks_prior_to_removed_chunks"),
    15: .standard(proto: "old_delivery_style_tuples"),
    16: .standard(proto: "old_chunk_ID_seeds"),
    17: .standard(proto: "old_chunk_identifiers"),
    18: .standard(proto: "working_builds"),
    19: .standard(proto: "chunks_removed_during_undo"),
    20: .standard(proto: "chunks_added_during_undo"),
  ]

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _slideID: TSP_UUID? = nil
    var _drawableIds: [TSP_UUID] = []
    var _expectedDeliveryStyleTuples: [TSP_Reference] = []
    var _chunksToAdd: [TSP_Reference] = []
    var _identifiersForChunksToInsertAfter: [KN_BuildChunkIdentifierArchive] = []
    var _identifiersForChunksToRemove: [KN_BuildChunkIdentifierArchive] = []
    var _tuplesToUpdate: [TSP_Reference] = []
    var _needsAsyncProcessChangesSelectionUpdate: Bool? = nil
    var _oldTuplesToUpdate: [TSP_Reference] = []
    var _identifiersForAddedChunks: [KN_BuildChunkIdentifierArchive] = []
    var _generatedIdentifiers: [KN_BuildChunkIdentifierArchive] = []
    var _removedChunks: [TSP_Reference] = []
    var _identifiersForChunksPriorToRemovedChunks: [KN_BuildChunkIdentifierArchive] = []
    var _oldDeliveryStyleTuples: [TSP_Reference] = []
    var _oldChunkIDSeeds: [UInt32] = []
    var _oldChunkIdentifiers: [KN_BuildChunkIdentifierArchive] = []
    var _workingBuilds: [TSP_Reference] = []
    var _chunksRemovedDuringUndo: [TSP_Reference] = []
    var _chunksAddedDuringUndo: [TSP_Reference] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _slideID = source._slideID
      _drawableIds = source._drawableIds
      _expectedDeliveryStyleTuples = source._expectedDeliveryStyleTuples
      _chunksToAdd = source._chunksToAdd
      _identifiersForChunksToInsertAfter = source._identifiersForChunksToInsertAfter
      _identifiersForChunksToRemove = source._identifiersForChunksToRemove
      _tuplesToUpdate = source._tuplesToUpdate
      _needsAsyncProcessChangesSelectionUpdate = source._needsAsyncProcessChangesSelectionUpdate
      _oldTuplesToUpdate = source._oldTuplesToUpdate
      _identifiersForAddedChunks = source._identifiersForAddedChunks
      _generatedIdentifiers = source._generatedIdentifiers
      _removedChunks = source._removedChunks
      _identifiersForChunksPriorToRemovedChunks = source._identifiersForChunksPriorToRemovedChunks
      _oldDeliveryStyleTuples = source._oldDeliveryStyleTuples
      _oldChunkIDSeeds = source._oldChunkIDSeeds
      _oldChunkIdentifiers = source._oldChunkIdentifiers
      _workingBuilds = source._workingBuilds
      _chunksRemovedDuringUndo = source._chunksRemovedDuringUndo
      _chunksAddedDuringUndo = source._chunksAddedDuringUndo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._slideID == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._slideID, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._drawableIds) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._expectedDeliveryStyleTuples) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._chunksToAdd) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._identifiersForChunksToInsertAfter) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._identifiersForChunksToRemove) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._tuplesToUpdate) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldTuplesToUpdate) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._identifiersForAddedChunks) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._generatedIdentifiers) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._removedChunks) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._identifiersForChunksPriorToRemovedChunks) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldDeliveryStyleTuples) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldChunkIdentifiers) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._workingBuilds) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._chunksRemovedDuringUndo) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._chunksAddedDuringUndo) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._super)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._slideID)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._drawableIds)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._expectedDeliveryStyleTuples)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._chunksToAdd)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._identifiersForChunksToInsertAfter)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._identifiersForChunksToRemove)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._tuplesToUpdate)
        case 9: try decoder.decodeSingularBoolField(value: &_storage._needsAsyncProcessChangesSelectionUpdate)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._oldTuplesToUpdate)
        case 11: try decoder.decodeRepeatedMessageField(value: &_storage._identifiersForAddedChunks)
        case 12: try decoder.decodeRepeatedMessageField(value: &_storage._generatedIdentifiers)
        case 13: try decoder.decodeRepeatedMessageField(value: &_storage._removedChunks)
        case 14: try decoder.decodeRepeatedMessageField(value: &_storage._identifiersForChunksPriorToRemovedChunks)
        case 15: try decoder.decodeRepeatedMessageField(value: &_storage._oldDeliveryStyleTuples)
        case 16: try decoder.decodeRepeatedUInt32Field(value: &_storage._oldChunkIDSeeds)
        case 17: try decoder.decodeRepeatedMessageField(value: &_storage._oldChunkIdentifiers)
        case 18: try decoder.decodeRepeatedMessageField(value: &_storage._workingBuilds)
        case 19: try decoder.decodeRepeatedMessageField(value: &_storage._chunksRemovedDuringUndo)
        case 20: try decoder.decodeRepeatedMessageField(value: &_storage._chunksAddedDuringUndo)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._slideID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._drawableIds.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._drawableIds, fieldNumber: 3)
      }
      if !_storage._expectedDeliveryStyleTuples.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._expectedDeliveryStyleTuples, fieldNumber: 4)
      }
      if !_storage._chunksToAdd.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chunksToAdd, fieldNumber: 5)
      }
      if !_storage._identifiersForChunksToInsertAfter.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._identifiersForChunksToInsertAfter, fieldNumber: 6)
      }
      if !_storage._identifiersForChunksToRemove.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._identifiersForChunksToRemove, fieldNumber: 7)
      }
      if !_storage._tuplesToUpdate.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tuplesToUpdate, fieldNumber: 8)
      }
      if let v = _storage._needsAsyncProcessChangesSelectionUpdate {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      }
      if !_storage._oldTuplesToUpdate.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldTuplesToUpdate, fieldNumber: 10)
      }
      if !_storage._identifiersForAddedChunks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._identifiersForAddedChunks, fieldNumber: 11)
      }
      if !_storage._generatedIdentifiers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._generatedIdentifiers, fieldNumber: 12)
      }
      if !_storage._removedChunks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._removedChunks, fieldNumber: 13)
      }
      if !_storage._identifiersForChunksPriorToRemovedChunks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._identifiersForChunksPriorToRemovedChunks, fieldNumber: 14)
      }
      if !_storage._oldDeliveryStyleTuples.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldDeliveryStyleTuples, fieldNumber: 15)
      }
      if !_storage._oldChunkIDSeeds.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._oldChunkIDSeeds, fieldNumber: 16)
      }
      if !_storage._oldChunkIdentifiers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldChunkIdentifiers, fieldNumber: 17)
      }
      if !_storage._workingBuilds.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._workingBuilds, fieldNumber: 18)
      }
      if !_storage._chunksRemovedDuringUndo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chunksRemovedDuringUndo, fieldNumber: 19)
      }
      if !_storage._chunksAddedDuringUndo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chunksAddedDuringUndo, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandBuildUpdateChunkCountArchive, rhs: KN_CommandBuildUpdateChunkCountArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._slideID != rhs_storage._slideID {return false}
        if _storage._drawableIds != rhs_storage._drawableIds {return false}
        if _storage._expectedDeliveryStyleTuples != rhs_storage._expectedDeliveryStyleTuples {return false}
        if _storage._chunksToAdd != rhs_storage._chunksToAdd {return false}
        if _storage._identifiersForChunksToInsertAfter != rhs_storage._identifiersForChunksToInsertAfter {return false}
        if _storage._identifiersForChunksToRemove != rhs_storage._identifiersForChunksToRemove {return false}
        if _storage._tuplesToUpdate != rhs_storage._tuplesToUpdate {return false}
        if _storage._needsAsyncProcessChangesSelectionUpdate != rhs_storage._needsAsyncProcessChangesSelectionUpdate {return false}
        if _storage._oldTuplesToUpdate != rhs_storage._oldTuplesToUpdate {return false}
        if _storage._identifiersForAddedChunks != rhs_storage._identifiersForAddedChunks {return false}
        if _storage._generatedIdentifiers != rhs_storage._generatedIdentifiers {return false}
        if _storage._removedChunks != rhs_storage._removedChunks {return false}
        if _storage._identifiersForChunksPriorToRemovedChunks != rhs_storage._identifiersForChunksPriorToRemovedChunks {return false}
        if _storage._oldDeliveryStyleTuples != rhs_storage._oldDeliveryStyleTuples {return false}
        if _storage._oldChunkIDSeeds != rhs_storage._oldChunkIDSeeds {return false}
        if _storage._oldChunkIdentifiers != rhs_storage._oldChunkIdentifiers {return false}
        if _storage._workingBuilds != rhs_storage._workingBuilds {return false}
        if _storage._chunksRemovedDuringUndo != rhs_storage._chunksRemovedDuringUndo {return false}
        if _storage._chunksAddedDuringUndo != rhs_storage._chunksAddedDuringUndo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandBuildChunkSetValueArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandBuildChunkSetValueArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "tuples_to_update"),
    3: .standard(proto: "old_tuples_to_update"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tuplesToUpdate) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldTuplesToUpdate) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.tuplesToUpdate)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.oldTuplesToUpdate)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.tuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tuplesToUpdate, fieldNumber: 2)
    }
    if !self.oldTuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldTuplesToUpdate, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandBuildChunkSetValueArchive, rhs: KN_CommandBuildChunkSetValueArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.tuplesToUpdate != rhs.tuplesToUpdate {return false}
    if lhs.oldTuplesToUpdate != rhs.oldTuplesToUpdate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandTransitionSetValueArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandTransitionSetValueArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "slide_node_id_path"),
    3: .standard(proto: "old_attributes"),
    4: .same(proto: "attributes"),
    5: .same(proto: "property"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideNodeIDPath == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._slideNodeIDPath, !v.isInitialized {return false}
    if let v = self._oldAttributes, !v.isInitialized {return false}
    if let v = self._attributes, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._slideNodeIDPath)
      case 3: try decoder.decodeSingularMessageField(value: &self._oldAttributes)
      case 4: try decoder.decodeSingularMessageField(value: &self._attributes)
      case 5: try decoder.decodeSingularStringField(value: &self._property)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._slideNodeIDPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._oldAttributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._attributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._property {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandTransitionSetValueArchive, rhs: KN_CommandTransitionSetValueArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideNodeIDPath != rhs._slideNodeIDPath {return false}
    if lhs._oldAttributes != rhs._oldAttributes {return false}
    if lhs._attributes != rhs._attributes {return false}
    if lhs._property != rhs._property {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowSetSlideNumberVisibilityArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowSetSlideNumberVisibilityArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    3: .standard(proto: "slide_numbers_visible"),
    4: .standard(proto: "ids_of_slide_nodes_to_skip"),
    5: .standard(proto: "ids_of_slide_nodes_already_correct"),
    6: .standard(proto: "is_undo"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideNumbersVisible == nil {return false}
    if self._isUndo == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.idsOfSlideNodesToSkip) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.idsOfSlideNodesAlreadyCorrect) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 3: try decoder.decodeSingularBoolField(value: &self._slideNumbersVisible)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.idsOfSlideNodesToSkip)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.idsOfSlideNodesAlreadyCorrect)
      case 6: try decoder.decodeSingularBoolField(value: &self._isUndo)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._slideNumbersVisible {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if !self.idsOfSlideNodesToSkip.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.idsOfSlideNodesToSkip, fieldNumber: 4)
    }
    if !self.idsOfSlideNodesAlreadyCorrect.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.idsOfSlideNodesAlreadyCorrect, fieldNumber: 5)
    }
    if let v = self._isUndo {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowSetSlideNumberVisibilityArchive, rhs: KN_CommandShowSetSlideNumberVisibilityArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideNumbersVisible != rhs._slideNumbersVisible {return false}
    if lhs.idsOfSlideNodesToSkip != rhs.idsOfSlideNodesToSkip {return false}
    if lhs.idsOfSlideNodesAlreadyCorrect != rhs.idsOfSlideNodesAlreadyCorrect {return false}
    if lhs._isUndo != rhs._isUndo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandMasterSetThumbnailTextArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandMasterSetThumbnailTextArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "master_id"),
    3: .standard(proto: "is_body"),
    4: .standard(proto: "new_text"),
    5: .standard(proto: "old_text"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._masterID == nil {return false}
    if self._isBody == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._masterID, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._masterID)
      case 3: try decoder.decodeSingularBoolField(value: &self._isBody)
      case 4: try decoder.decodeSingularStringField(value: &self._newText)
      case 5: try decoder.decodeSingularStringField(value: &self._oldText)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._masterID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._isBody {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._newText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._oldText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandMasterSetThumbnailTextArchive, rhs: KN_CommandMasterSetThumbnailTextArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._masterID != rhs._masterID {return false}
    if lhs._isBody != rhs._isBody {return false}
    if lhs._newText != rhs._newText {return false}
    if lhs._oldText != rhs._oldText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandMasterSetBodyStylesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandMasterSetBodyStylesArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "master_id"),
    3: .standard(proto: "new_paragraph_styles"),
    4: .standard(proto: "new_list_styles"),
    5: .standard(proto: "old_paragraph_styles"),
    6: .standard(proto: "old_list_styles"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._masterID == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._masterID, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.newParagraphStyles) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.newListStyles) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldParagraphStyles) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldListStyles) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._masterID)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.newParagraphStyles)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.newListStyles)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.oldParagraphStyles)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.oldListStyles)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._masterID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.newParagraphStyles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.newParagraphStyles, fieldNumber: 3)
    }
    if !self.newListStyles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.newListStyles, fieldNumber: 4)
    }
    if !self.oldParagraphStyles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldParagraphStyles, fieldNumber: 5)
    }
    if !self.oldListStyles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldListStyles, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandMasterSetBodyStylesArchive, rhs: KN_CommandMasterSetBodyStylesArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._masterID != rhs._masterID {return false}
    if lhs.newParagraphStyles != rhs.newParagraphStyles {return false}
    if lhs.newListStyles != rhs.newListStyles {return false}
    if lhs.oldParagraphStyles != rhs.oldParagraphStyles {return false}
    if lhs.oldListStyles != rhs.oldListStyles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandChangeMasterSlideArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandChangeMasterSlideArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "slide_id_path"),
    3: .standard(proto: "master_node"),
    4: .standard(proto: "old_master_node"),
    5: .standard(proto: "is_undo_redo"),
    6: .standard(proto: "target_prototype"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideIDPath == nil {return false}
    if self._masterNode == nil {return false}
    if self._isUndoRedo == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._slideIDPath, !v.isInitialized {return false}
    if let v = self._masterNode, !v.isInitialized {return false}
    if let v = self._oldMasterNode, !v.isInitialized {return false}
    if let v = self._targetPrototype, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._slideIDPath)
      case 3: try decoder.decodeSingularMessageField(value: &self._masterNode)
      case 4: try decoder.decodeSingularMessageField(value: &self._oldMasterNode)
      case 5: try decoder.decodeSingularBoolField(value: &self._isUndoRedo)
      case 6: try decoder.decodeSingularMessageField(value: &self._targetPrototype)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._slideIDPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._masterNode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._oldMasterNode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._isUndoRedo {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    if let v = self._targetPrototype {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandChangeMasterSlideArchive, rhs: KN_CommandChangeMasterSlideArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideIDPath != rhs._slideIDPath {return false}
    if lhs._masterNode != rhs._masterNode {return false}
    if lhs._oldMasterNode != rhs._oldMasterNode {return false}
    if lhs._isUndoRedo != rhs._isUndoRedo {return false}
    if lhs._targetPrototype != rhs._targetPrototype {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlidePrimitiveSetMasterArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlidePrimitiveSetMasterArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "slide_id_path"),
    3: .standard(proto: "master_id"),
    4: .standard(proto: "old_master_node"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideIDPath == nil {return false}
    if self._masterID == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._slideIDPath, !v.isInitialized {return false}
    if let v = self._masterID, !v.isInitialized {return false}
    if let v = self._oldMasterNode, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._slideIDPath)
      case 3: try decoder.decodeSingularMessageField(value: &self._masterID)
      case 4: try decoder.decodeSingularMessageField(value: &self._oldMasterNode)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._slideIDPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._masterID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._oldMasterNode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlidePrimitiveSetMasterArchive, rhs: KN_CommandSlidePrimitiveSetMasterArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideIDPath != rhs._slideIDPath {return false}
    if lhs._masterID != rhs._masterID {return false}
    if lhs._oldMasterNode != rhs._oldMasterNode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideResetMasterBackgroundObjectsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideResetMasterBackgroundObjectsArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "slide_id_path"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._slideIDPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._slideIDPath)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._slideIDPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideResetMasterBackgroundObjectsArchive, rhs: KN_CommandSlideResetMasterBackgroundObjectsArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideIDPath != rhs._slideIDPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowSetSoundtrack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowSetSoundtrack"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .same(proto: "show"),
    3: .same(proto: "soundtrack"),
    4: .standard(proto: "old_soundtrack"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._show, !v.isInitialized {return false}
    if let v = self._soundtrack, !v.isInitialized {return false}
    if let v = self._oldSoundtrack, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._show)
      case 3: try decoder.decodeSingularMessageField(value: &self._soundtrack)
      case 4: try decoder.decodeSingularMessageField(value: &self._oldSoundtrack)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._show {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._soundtrack {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._oldSoundtrack {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowSetSoundtrack, rhs: KN_CommandShowSetSoundtrack) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._show != rhs._show {return false}
    if lhs._soundtrack != rhs._soundtrack {return false}
    if lhs._oldSoundtrack != rhs._oldSoundtrack {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSoundtrackSetValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSoundtrackSetValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "soundtrack_id"),
    3: .same(proto: "property"),
    4: .standard(proto: "old_value"),
    5: .standard(proto: "new_value"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._soundtrackID, !v.isInitialized {return false}
    if let v = self._oldValue, !v.isInitialized {return false}
    if let v = self._newValue, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._soundtrackID)
      case 3: try decoder.decodeSingularStringField(value: &self._property)
      case 4: try decoder.decodeSingularMessageField(value: &self._oldValue)
      case 5: try decoder.decodeSingularMessageField(value: &self._newValue)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._soundtrackID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._property {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._oldValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._newValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSoundtrackSetValue, rhs: KN_CommandSoundtrackSetValue) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._soundtrackID != rhs._soundtrackID {return false}
    if lhs._property != rhs._property {return false}
    if lhs._oldValue != rhs._oldValue {return false}
    if lhs._newValue != rhs._newValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSoundtrackSetValue.PropertyValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = KN_CommandSoundtrackSetValue.protoMessageName + ".PropertyValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "double_value"),
    2: .standard(proto: "mode_value"),
    3: .standard(proto: "media_reference_values"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.mediaReferenceValues) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self._doubleValue)
      case 2: try decoder.decodeSingularEnumField(value: &self._modeValue)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.mediaReferenceValues)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._doubleValue {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    }
    if let v = self._modeValue {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    if !self.mediaReferenceValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mediaReferenceValues, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSoundtrackSetValue.PropertyValue, rhs: KN_CommandSoundtrackSetValue.PropertyValue) -> Bool {
    if lhs._doubleValue != rhs._doubleValue {return false}
    if lhs._modeValue != rhs._modeValue {return false}
    if lhs.mediaReferenceValues != rhs.mediaReferenceValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideUpdateMasterDrawables: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideUpdateMasterDrawables"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "slide_id"),
    3: .standard(proto: "id_placement_operation_args"),
    4: .standard(proto: "old_child_infos_for_undo"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideID == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._slideID, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.idPlacementOperationArgs) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldChildInfosForUndo) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._slideID)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.idPlacementOperationArgs)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.oldChildInfosForUndo)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._slideID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.idPlacementOperationArgs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.idPlacementOperationArgs, fieldNumber: 3)
    }
    if !self.oldChildInfosForUndo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldChildInfosForUndo, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideUpdateMasterDrawables, rhs: KN_CommandSlideUpdateMasterDrawables) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideID != rhs._slideID {return false}
    if lhs.idPlacementOperationArgs != rhs.idPlacementOperationArgs {return false}
    if lhs.oldChildInfosForUndo != rhs.oldChildInfosForUndo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_ChartInfoGeometryCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChartInfoGeometryCommandArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "previous_legend_offset"),
    3: .standard(proto: "previous_legend_size"),
    4: .standard(proto: "adjusted_legend_offset"),
    5: .standard(proto: "adjusted_legend_size"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._previousLegendOffset == nil {return false}
    if self._previousLegendSize == nil {return false}
    if self._adjustedLegendOffset == nil {return false}
    if self._adjustedLegendSize == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._previousLegendOffset, !v.isInitialized {return false}
    if let v = self._previousLegendSize, !v.isInitialized {return false}
    if let v = self._adjustedLegendOffset, !v.isInitialized {return false}
    if let v = self._adjustedLegendSize, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._previousLegendOffset)
      case 3: try decoder.decodeSingularMessageField(value: &self._previousLegendSize)
      case 4: try decoder.decodeSingularMessageField(value: &self._adjustedLegendOffset)
      case 5: try decoder.decodeSingularMessageField(value: &self._adjustedLegendSize)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._previousLegendOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._previousLegendSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._adjustedLegendOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._adjustedLegendSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_ChartInfoGeometryCommandArchive, rhs: KN_ChartInfoGeometryCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._previousLegendOffset != rhs._previousLegendOffset {return false}
    if lhs._previousLegendSize != rhs._previousLegendSize {return false}
    if lhs._adjustedLegendOffset != rhs._adjustedLegendOffset {return false}
    if lhs._adjustedLegendSize != rhs._adjustedLegendSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CanvasSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CanvasSelectionTransformerArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transformer_helper"),
    2: .standard(proto: "build_chunk_ids"),
    3: .standard(proto: "action_build_ids"),
    4: .standard(proto: "originally_selected_drawable_uuids"),
  ]

  public var isInitialized: Bool {
    if self._transformerHelper == nil {return false}
    if let v = self._transformerHelper, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.buildChunkIds) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.actionBuildIds) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.originallySelectedDrawableUuids) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._transformerHelper)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.buildChunkIds)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.actionBuildIds)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.originallySelectedDrawableUuids)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._transformerHelper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.buildChunkIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buildChunkIds, fieldNumber: 2)
    }
    if !self.actionBuildIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actionBuildIds, fieldNumber: 3)
    }
    if !self.originallySelectedDrawableUuids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.originallySelectedDrawableUuids, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CanvasSelectionTransformerArchive, rhs: KN_CanvasSelectionTransformerArchive) -> Bool {
    if lhs._transformerHelper != rhs._transformerHelper {return false}
    if lhs.buildChunkIds != rhs.buildChunkIds {return false}
    if lhs.actionBuildIds != rhs.actionBuildIds {return false}
    if lhs.originallySelectedDrawableUuids != rhs.originallySelectedDrawableUuids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_ActionGhostSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionGhostSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_ActionGhostSelectionTransformerArchive, rhs: KN_ActionGhostSelectionTransformerArchive) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_DocumentSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentSelectionTransformerArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "document_selection"),
  ]

  public var isInitialized: Bool {
    if self._documentSelection == nil {return false}
    if let v = self._documentSelection, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._documentSelection)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._documentSelection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_DocumentSelectionTransformerArchive, rhs: KN_DocumentSelectionTransformerArchive) -> Bool {
    if lhs._documentSelection != rhs._documentSelection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_NoteCanvasSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NoteCanvasSelectionTransformerArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transformer_helper"),
  ]

  public var isInitialized: Bool {
    if self._transformerHelper == nil {return false}
    if let v = self._transformerHelper, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._transformerHelper)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._transformerHelper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_NoteCanvasSelectionTransformerArchive, rhs: KN_NoteCanvasSelectionTransformerArchive) -> Bool {
    if lhs._transformerHelper != rhs._transformerHelper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_OutlineCanvasSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OutlineCanvasSelectionTransformerArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "canvas_selection_transformer"),
    2: .standard(proto: "storage_uuid_path"),
  ]

  public var isInitialized: Bool {
    if self._canvasSelectionTransformer == nil {return false}
    if let v = self._canvasSelectionTransformer, !v.isInitialized {return false}
    if let v = self._storageUuidPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._canvasSelectionTransformer)
      case 2: try decoder.decodeSingularMessageField(value: &self._storageUuidPath)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._canvasSelectionTransformer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._storageUuidPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_OutlineCanvasSelectionTransformerArchive, rhs: KN_OutlineCanvasSelectionTransformerArchive) -> Bool {
    if lhs._canvasSelectionTransformer != rhs._canvasSelectionTransformer {return false}
    if lhs._storageUuidPath != rhs._storageUuidPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_SlideCollectionSelectionTransformerHelperArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SlideCollectionSelectionTransformerHelperArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "slide_nodes"),
    2: .standard(proto: "slide_node_to_edit"),
    3: .standard(proto: "slide_collection_is_theme"),
    4: .standard(proto: "previous_primary_selected_index"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.slideNodes) {return false}
    if let v = self._slideNodeToEdit, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.slideNodes)
      case 2: try decoder.decodeSingularMessageField(value: &self._slideNodeToEdit)
      case 3: try decoder.decodeSingularBoolField(value: &self._slideCollectionIsTheme)
      case 4: try decoder.decodeSingularUInt32Field(value: &self._previousPrimarySelectedIndex)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.slideNodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.slideNodes, fieldNumber: 1)
    }
    if let v = self._slideNodeToEdit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._slideCollectionIsTheme {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._previousPrimarySelectedIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_SlideCollectionSelectionTransformerHelperArchive, rhs: KN_SlideCollectionSelectionTransformerHelperArchive) -> Bool {
    if lhs.slideNodes != rhs.slideNodes {return false}
    if lhs._slideNodeToEdit != rhs._slideNodeToEdit {return false}
    if lhs._slideCollectionIsTheme != rhs._slideCollectionIsTheme {return false}
    if lhs._previousPrimarySelectedIndex != rhs._previousPrimarySelectedIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_SlideCollectionSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SlideCollectionSelectionTransformerArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transformer_helper"),
  ]

  public var isInitialized: Bool {
    if self._transformerHelper == nil {return false}
    if let v = self._transformerHelper, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._transformerHelper)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._transformerHelper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_SlideCollectionSelectionTransformerArchive, rhs: KN_SlideCollectionSelectionTransformerArchive) -> Bool {
    if lhs._transformerHelper != rhs._transformerHelper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_OutlineSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OutlineSelectionTransformerArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transformer_helper"),
    2: .standard(proto: "can_have_range_in_selected_paragraph"),
    3: .standard(proto: "selection_range_addresses"),
  ]

  public var isInitialized: Bool {
    if self._transformerHelper == nil {return false}
    if let v = self._transformerHelper, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._transformerHelper)
      case 2: try decoder.decodeSingularBoolField(value: &self._canHaveRangeInSelectedParagraph)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.selectionRangeAddresses)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._transformerHelper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._canHaveRangeInSelectedParagraph {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if !self.selectionRangeAddresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.selectionRangeAddresses, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_OutlineSelectionTransformerArchive, rhs: KN_OutlineSelectionTransformerArchive) -> Bool {
    if lhs._transformerHelper != rhs._transformerHelper {return false}
    if lhs._canHaveRangeInSelectedParagraph != rhs._canHaveRangeInSelectedParagraph {return false}
    if lhs.selectionRangeAddresses != rhs.selectionRangeAddresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
