// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TSSArchives.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum TSS_ValueType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case objectType // = 0
  case intType // = 1
  case floatType // = 2
  case doubleType // = 3

  init() {
    self = .objectType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .objectType
    case 1: self = .intType
    case 2: self = .floatType
    case 3: self = .doubleType
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .objectType: return 0
    case .intType: return 1
    case .floatType: return 2
    case .doubleType: return 3
    }
  }

}

#if swift(>=4.2)

extension TSS_ValueType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum TSS_PropertyType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case invalidPropertyType // = 1
  case nullPropertyType // = 2
  case integerPropertyType // = 3
  case floatPropertyType // = 4
  case doublePropertyType // = 5
  case nsstringPropertyType // = 6
  case tspobjectPropertyType // = 7

  init() {
    self = .invalidPropertyType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .invalidPropertyType
    case 2: self = .nullPropertyType
    case 3: self = .integerPropertyType
    case 4: self = .floatPropertyType
    case 5: self = .doublePropertyType
    case 6: self = .nsstringPropertyType
    case 7: self = .tspobjectPropertyType
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .invalidPropertyType: return 1
    case .nullPropertyType: return 2
    case .integerPropertyType: return 3
    case .floatPropertyType: return 4
    case .doublePropertyType: return 5
    case .nsstringPropertyType: return 6
    case .tspobjectPropertyType: return 7
    }
  }

}

#if swift(>=4.2)

extension TSS_PropertyType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct TSS_StyleArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var styleIdentifier: String {
    get {return _styleIdentifier ?? String()}
    set {_styleIdentifier = newValue}
  }
  /// Returns true if `styleIdentifier` has been explicitly set.
  var hasStyleIdentifier: Bool {return self._styleIdentifier != nil}
  /// Clears the value of `styleIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearStyleIdentifier() {self._styleIdentifier = nil}

  var parent: TSP_Reference {
    get {return _parent ?? TSP_Reference()}
    set {_parent = newValue}
  }
  /// Returns true if `parent` has been explicitly set.
  var hasParent: Bool {return self._parent != nil}
  /// Clears the value of `parent`. Subsequent reads from it will return its default value.
  mutating func clearParent() {self._parent = nil}

  var isVariation: Bool {
    get {return _isVariation ?? false}
    set {_isVariation = newValue}
  }
  /// Returns true if `isVariation` has been explicitly set.
  var hasIsVariation: Bool {return self._isVariation != nil}
  /// Clears the value of `isVariation`. Subsequent reads from it will return its default value.
  mutating func clearIsVariation() {self._isVariation = nil}

  var stylesheet: TSP_Reference {
    get {return _stylesheet ?? TSP_Reference()}
    set {_stylesheet = newValue}
  }
  /// Returns true if `stylesheet` has been explicitly set.
  var hasStylesheet: Bool {return self._stylesheet != nil}
  /// Clears the value of `stylesheet`. Subsequent reads from it will return its default value.
  mutating func clearStylesheet() {self._stylesheet = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _styleIdentifier: String? = nil
  fileprivate var _parent: TSP_Reference? = nil
  fileprivate var _isVariation: Bool? = nil
  fileprivate var _stylesheet: TSP_Reference? = nil
}

struct TSS_StylesheetArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var styles: [TSP_Reference] = []

  var identifierToStyleMap: [TSS_StylesheetArchive.IdentifiedStyleEntry] = []

  var parent: TSP_Reference {
    get {return _parent ?? TSP_Reference()}
    set {_parent = newValue}
  }
  /// Returns true if `parent` has been explicitly set.
  var hasParent: Bool {return self._parent != nil}
  /// Clears the value of `parent`. Subsequent reads from it will return its default value.
  mutating func clearParent() {self._parent = nil}

  var isLocked: Bool {
    get {return _isLocked ?? true}
    set {_isLocked = newValue}
  }
  /// Returns true if `isLocked` has been explicitly set.
  var hasIsLocked: Bool {return self._isLocked != nil}
  /// Clears the value of `isLocked`. Subsequent reads from it will return its default value.
  mutating func clearIsLocked() {self._isLocked = nil}

  var parentToChildrenStyleMap: [TSS_StylesheetArchive.StyleChildrenEntry] = []

  var canCullStyles: Bool {
    get {return _canCullStyles ?? false}
    set {_canCullStyles = newValue}
  }
  /// Returns true if `canCullStyles` has been explicitly set.
  var hasCanCullStyles: Bool {return self._canCullStyles != nil}
  /// Clears the value of `canCullStyles`. Subsequent reads from it will return its default value.
  mutating func clearCanCullStyles() {self._canCullStyles = nil}

  var stylesFor100: TSS_StylesheetArchive.VersionedStyles {
    get {return _stylesFor100 ?? TSS_StylesheetArchive.VersionedStyles()}
    set {_stylesFor100 = newValue}
  }
  /// Returns true if `stylesFor100` has been explicitly set.
  var hasStylesFor100: Bool {return self._stylesFor100 != nil}
  /// Clears the value of `stylesFor100`. Subsequent reads from it will return its default value.
  mutating func clearStylesFor100() {self._stylesFor100 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct IdentifiedStyleEntry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identifier: String {
      get {return _identifier ?? String()}
      set {_identifier = newValue}
    }
    /// Returns true if `identifier` has been explicitly set.
    var hasIdentifier: Bool {return self._identifier != nil}
    /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
    mutating func clearIdentifier() {self._identifier = nil}

    var style: TSP_Reference {
      get {return _style ?? TSP_Reference()}
      set {_style = newValue}
    }
    /// Returns true if `style` has been explicitly set.
    var hasStyle: Bool {return self._style != nil}
    /// Clears the value of `style`. Subsequent reads from it will return its default value.
    mutating func clearStyle() {self._style = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _identifier: String? = nil
    fileprivate var _style: TSP_Reference? = nil
  }

  struct StyleChildrenEntry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parent: TSP_Reference {
      get {return _parent ?? TSP_Reference()}
      set {_parent = newValue}
    }
    /// Returns true if `parent` has been explicitly set.
    var hasParent: Bool {return self._parent != nil}
    /// Clears the value of `parent`. Subsequent reads from it will return its default value.
    mutating func clearParent() {self._parent = nil}

    var children: [TSP_Reference] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _parent: TSP_Reference? = nil
  }

  struct VersionedStyles {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var styles: [TSP_Reference] = []

    var identifierToStyleMap: [TSS_StylesheetArchive.IdentifiedStyleEntry] = []

    var parentToChildrenStyleMap: [TSS_StylesheetArchive.StyleChildrenEntry] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _parent: TSP_Reference? = nil
  fileprivate var _isLocked: Bool? = nil
  fileprivate var _canCullStyles: Bool? = nil
  fileprivate var _stylesFor100: TSS_StylesheetArchive.VersionedStyles? = nil
}

struct TSS_ThemeArchive: SwiftProtobuf.ExtensibleMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var legacyStylesheet: TSP_Reference {
    get {return _legacyStylesheet ?? TSP_Reference()}
    set {_legacyStylesheet = newValue}
  }
  /// Returns true if `legacyStylesheet` has been explicitly set.
  var hasLegacyStylesheet: Bool {return self._legacyStylesheet != nil}
  /// Clears the value of `legacyStylesheet`. Subsequent reads from it will return its default value.
  mutating func clearLegacyStylesheet() {self._legacyStylesheet = nil}

  var themeIdentifier: String {
    get {return _themeIdentifier ?? String()}
    set {_themeIdentifier = newValue}
  }
  /// Returns true if `themeIdentifier` has been explicitly set.
  var hasThemeIdentifier: Bool {return self._themeIdentifier != nil}
  /// Clears the value of `themeIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearThemeIdentifier() {self._themeIdentifier = nil}

  var documentStylesheet: TSP_Reference {
    get {return _documentStylesheet ?? TSP_Reference()}
    set {_documentStylesheet = newValue}
  }
  /// Returns true if `documentStylesheet` has been explicitly set.
  var hasDocumentStylesheet: Bool {return self._documentStylesheet != nil}
  /// Clears the value of `documentStylesheet`. Subsequent reads from it will return its default value.
  mutating func clearDocumentStylesheet() {self._documentStylesheet = nil}

  var oldUuidsForPresetReplacements: [TSP_UUID] = []

  var newUuidsForPresetReplacements: [TSP_UUID] = []

  var colorPresets: [TSP_Color] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _legacyStylesheet: TSP_Reference? = nil
  fileprivate var _themeIdentifier: String? = nil
  fileprivate var _documentStylesheet: TSP_Reference? = nil
}

struct TSS_ApplyThemeCommandArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var commands: [TSP_Reference] = []

  var oldTheme: TSP_Reference {
    get {return _oldTheme ?? TSP_Reference()}
    set {_oldTheme = newValue}
  }
  /// Returns true if `oldTheme` has been explicitly set.
  var hasOldTheme: Bool {return self._oldTheme != nil}
  /// Clears the value of `oldTheme`. Subsequent reads from it will return its default value.
  mutating func clearOldTheme() {self._oldTheme = nil}

  var newTheme: TSP_Reference {
    get {return _newTheme ?? TSP_Reference()}
    set {_newTheme = newValue}
  }
  /// Returns true if `newTheme` has been explicitly set.
  var hasNewTheme: Bool {return self._newTheme != nil}
  /// Clears the value of `newTheme`. Subsequent reads from it will return its default value.
  mutating func clearNewTheme() {self._newTheme = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _oldTheme: TSP_Reference? = nil
  fileprivate var _newTheme: TSP_Reference? = nil
}

struct TSS_ApplyThemeChildCommandArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var parent: TSP_Reference {
    get {return _parent ?? TSP_Reference()}
    set {_parent = newValue}
  }
  /// Returns true if `parent` has been explicitly set.
  var hasParent: Bool {return self._parent != nil}
  /// Clears the value of `parent`. Subsequent reads from it will return its default value.
  mutating func clearParent() {self._parent = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _parent: TSP_Reference? = nil
}

struct TSS_StyleUpdatePropertyMapCommandArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var currentStyle: TSP_Reference {
    get {return _currentStyle ?? TSP_Reference()}
    set {_currentStyle = newValue}
  }
  /// Returns true if `currentStyle` has been explicitly set.
  var hasCurrentStyle: Bool {return self._currentStyle != nil}
  /// Clears the value of `currentStyle`. Subsequent reads from it will return its default value.
  mutating func clearCurrentStyle() {self._currentStyle = nil}

  var styleWithOldPropertyMap: TSP_Reference {
    get {return _styleWithOldPropertyMap ?? TSP_Reference()}
    set {_styleWithOldPropertyMap = newValue}
  }
  /// Returns true if `styleWithOldPropertyMap` has been explicitly set.
  var hasStyleWithOldPropertyMap: Bool {return self._styleWithOldPropertyMap != nil}
  /// Clears the value of `styleWithOldPropertyMap`. Subsequent reads from it will return its default value.
  mutating func clearStyleWithOldPropertyMap() {self._styleWithOldPropertyMap = nil}

  var styleWithNewPropertyMap: TSP_Reference {
    get {return _styleWithNewPropertyMap ?? TSP_Reference()}
    set {_styleWithNewPropertyMap = newValue}
  }
  /// Returns true if `styleWithNewPropertyMap` has been explicitly set.
  var hasStyleWithNewPropertyMap: Bool {return self._styleWithNewPropertyMap != nil}
  /// Clears the value of `styleWithNewPropertyMap`. Subsequent reads from it will return its default value.
  mutating func clearStyleWithNewPropertyMap() {self._styleWithNewPropertyMap = nil}

  var styleDiff: TSP_Reference {
    get {return _styleDiff ?? TSP_Reference()}
    set {_styleDiff = newValue}
  }
  /// Returns true if `styleDiff` has been explicitly set.
  var hasStyleDiff: Bool {return self._styleDiff != nil}
  /// Clears the value of `styleDiff`. Subsequent reads from it will return its default value.
  mutating func clearStyleDiff() {self._styleDiff = nil}

  var notifyForStyleClients: Bool {
    get {return _notifyForStyleClients ?? true}
    set {_notifyForStyleClients = newValue}
  }
  /// Returns true if `notifyForStyleClients` has been explicitly set.
  var hasNotifyForStyleClients: Bool {return self._notifyForStyleClients != nil}
  /// Clears the value of `notifyForStyleClients`. Subsequent reads from it will return its default value.
  mutating func clearNotifyForStyleClients() {self._notifyForStyleClients = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _currentStyle: TSP_Reference? = nil
  fileprivate var _styleWithOldPropertyMap: TSP_Reference? = nil
  fileprivate var _styleWithNewPropertyMap: TSP_Reference? = nil
  fileprivate var _styleDiff: TSP_Reference? = nil
  fileprivate var _notifyForStyleClients: Bool? = nil
}

struct TSS_ThemeReplacePresetCommandArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var preset: TSP_Reference {
    get {return _preset ?? TSP_Reference()}
    set {_preset = newValue}
  }
  /// Returns true if `preset` has been explicitly set.
  var hasPreset: Bool {return self._preset != nil}
  /// Clears the value of `preset`. Subsequent reads from it will return its default value.
  mutating func clearPreset() {self._preset = nil}

  var oldPreset: TSP_Reference {
    get {return _oldPreset ?? TSP_Reference()}
    set {_oldPreset = newValue}
  }
  /// Returns true if `oldPreset` has been explicitly set.
  var hasOldPreset: Bool {return self._oldPreset != nil}
  /// Clears the value of `oldPreset`. Subsequent reads from it will return its default value.
  mutating func clearOldPreset() {self._oldPreset = nil}

  var index: UInt32 {
    get {return _index ?? 0}
    set {_index = newValue}
  }
  /// Returns true if `index` has been explicitly set.
  var hasIndex: Bool {return self._index != nil}
  /// Clears the value of `index`. Subsequent reads from it will return its default value.
  mutating func clearIndex() {self._index = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _preset: TSP_Reference? = nil
  fileprivate var _oldPreset: TSP_Reference? = nil
  fileprivate var _index: UInt32? = nil
}

struct TSS_ThemeReplaceColorPresetCommandArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var theme: TSP_Reference {
    get {return _theme ?? TSP_Reference()}
    set {_theme = newValue}
  }
  /// Returns true if `theme` has been explicitly set.
  var hasTheme: Bool {return self._theme != nil}
  /// Clears the value of `theme`. Subsequent reads from it will return its default value.
  mutating func clearTheme() {self._theme = nil}

  var color: TSP_Color {
    get {return _color ?? TSP_Color()}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {self._color = nil}

  var oldColor: TSP_Color {
    get {return _oldColor ?? TSP_Color()}
    set {_oldColor = newValue}
  }
  /// Returns true if `oldColor` has been explicitly set.
  var hasOldColor: Bool {return self._oldColor != nil}
  /// Clears the value of `oldColor`. Subsequent reads from it will return its default value.
  mutating func clearOldColor() {self._oldColor = nil}

  var index: UInt32 {
    get {return _index ?? 0}
    set {_index = newValue}
  }
  /// Returns true if `index` has been explicitly set.
  var hasIndex: Bool {return self._index != nil}
  /// Clears the value of `index`. Subsequent reads from it will return its default value.
  mutating func clearIndex() {self._index = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _theme: TSP_Reference? = nil
  fileprivate var _color: TSP_Color? = nil
  fileprivate var _oldColor: TSP_Color? = nil
  fileprivate var _index: UInt32? = nil
}

struct TSS_ThemeAddStylePresetCommandArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var theme: TSP_Reference {
    get {return _theme ?? TSP_Reference()}
    set {_theme = newValue}
  }
  /// Returns true if `theme` has been explicitly set.
  var hasTheme: Bool {return self._theme != nil}
  /// Clears the value of `theme`. Subsequent reads from it will return its default value.
  mutating func clearTheme() {self._theme = nil}

  var preset: TSP_Reference {
    get {return _preset ?? TSP_Reference()}
    set {_preset = newValue}
  }
  /// Returns true if `preset` has been explicitly set.
  var hasPreset: Bool {return self._preset != nil}
  /// Clears the value of `preset`. Subsequent reads from it will return its default value.
  mutating func clearPreset() {self._preset = nil}

  var presetKind: String {
    get {return _presetKind ?? String()}
    set {_presetKind = newValue}
  }
  /// Returns true if `presetKind` has been explicitly set.
  var hasPresetKind: Bool {return self._presetKind != nil}
  /// Clears the value of `presetKind`. Subsequent reads from it will return its default value.
  mutating func clearPresetKind() {self._presetKind = nil}

  var identifier: String {
    get {return _identifier ?? String()}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  var addPresetToStylesheet: Bool {
    get {return _addPresetToStylesheet ?? false}
    set {_addPresetToStylesheet = newValue}
  }
  /// Returns true if `addPresetToStylesheet` has been explicitly set.
  var hasAddPresetToStylesheet: Bool {return self._addPresetToStylesheet != nil}
  /// Clears the value of `addPresetToStylesheet`. Subsequent reads from it will return its default value.
  mutating func clearAddPresetToStylesheet() {self._addPresetToStylesheet = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _theme: TSP_Reference? = nil
  fileprivate var _preset: TSP_Reference? = nil
  fileprivate var _presetKind: String? = nil
  fileprivate var _identifier: String? = nil
  fileprivate var _addPresetToStylesheet: Bool? = nil
}

struct TSS_ThemeRemoveStylePresetCommandArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var theme: TSP_Reference {
    get {return _theme ?? TSP_Reference()}
    set {_theme = newValue}
  }
  /// Returns true if `theme` has been explicitly set.
  var hasTheme: Bool {return self._theme != nil}
  /// Clears the value of `theme`. Subsequent reads from it will return its default value.
  mutating func clearTheme() {self._theme = nil}

  var preset: TSP_Reference {
    get {return _preset ?? TSP_Reference()}
    set {_preset = newValue}
  }
  /// Returns true if `preset` has been explicitly set.
  var hasPreset: Bool {return self._preset != nil}
  /// Clears the value of `preset`. Subsequent reads from it will return its default value.
  mutating func clearPreset() {self._preset = nil}

  var presetIndex: UInt32 {
    get {return _presetIndex ?? 0}
    set {_presetIndex = newValue}
  }
  /// Returns true if `presetIndex` has been explicitly set.
  var hasPresetIndex: Bool {return self._presetIndex != nil}
  /// Clears the value of `presetIndex`. Subsequent reads from it will return its default value.
  mutating func clearPresetIndex() {self._presetIndex = nil}

  var presetKind: String {
    get {return _presetKind ?? String()}
    set {_presetKind = newValue}
  }
  /// Returns true if `presetKind` has been explicitly set.
  var hasPresetKind: Bool {return self._presetKind != nil}
  /// Clears the value of `presetKind`. Subsequent reads from it will return its default value.
  mutating func clearPresetKind() {self._presetKind = nil}

  var identifier: String {
    get {return _identifier ?? String()}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  var replacementPreset: TSP_Reference {
    get {return _replacementPreset ?? TSP_Reference()}
    set {_replacementPreset = newValue}
  }
  /// Returns true if `replacementPreset` has been explicitly set.
  var hasReplacementPreset: Bool {return self._replacementPreset != nil}
  /// Clears the value of `replacementPreset`. Subsequent reads from it will return its default value.
  mutating func clearReplacementPreset() {self._replacementPreset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _theme: TSP_Reference? = nil
  fileprivate var _preset: TSP_Reference? = nil
  fileprivate var _presetIndex: UInt32? = nil
  fileprivate var _presetKind: String? = nil
  fileprivate var _identifier: String? = nil
  fileprivate var _replacementPreset: TSP_Reference? = nil
}

struct TSS_ThemeMovePresetCommandArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var theme: TSP_Reference {
    get {return _theme ?? TSP_Reference()}
    set {_theme = newValue}
  }
  /// Returns true if `theme` has been explicitly set.
  var hasTheme: Bool {return self._theme != nil}
  /// Clears the value of `theme`. Subsequent reads from it will return its default value.
  mutating func clearTheme() {self._theme = nil}

  var presetID: TSP_UUID {
    get {return _presetID ?? TSP_UUID()}
    set {_presetID = newValue}
  }
  /// Returns true if `presetID` has been explicitly set.
  var hasPresetID: Bool {return self._presetID != nil}
  /// Clears the value of `presetID`. Subsequent reads from it will return its default value.
  mutating func clearPresetID() {self._presetID = nil}

  var newIndex: UInt32 {
    get {return _newIndex ?? 0}
    set {_newIndex = newValue}
  }
  /// Returns true if `newIndex` has been explicitly set.
  var hasNewIndex: Bool {return self._newIndex != nil}
  /// Clears the value of `newIndex`. Subsequent reads from it will return its default value.
  mutating func clearNewIndex() {self._newIndex = nil}

  var oldIndex: UInt32 {
    get {return _oldIndex ?? 0}
    set {_oldIndex = newValue}
  }
  /// Returns true if `oldIndex` has been explicitly set.
  var hasOldIndex: Bool {return self._oldIndex != nil}
  /// Clears the value of `oldIndex`. Subsequent reads from it will return its default value.
  mutating func clearOldIndex() {self._oldIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _theme: TSP_Reference? = nil
  fileprivate var _presetID: TSP_UUID? = nil
  fileprivate var _newIndex: UInt32? = nil
  fileprivate var _oldIndex: UInt32? = nil
}

struct TSS_ThemeReplaceStylePresetAndDisconnectStylesCommandArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var preset: TSP_Reference {
    get {return _preset ?? TSP_Reference()}
    set {_preset = newValue}
  }
  /// Returns true if `preset` has been explicitly set.
  var hasPreset: Bool {return self._preset != nil}
  /// Clears the value of `preset`. Subsequent reads from it will return its default value.
  mutating func clearPreset() {self._preset = nil}

  var replacementPreset: TSP_Reference {
    get {return _replacementPreset ?? TSP_Reference()}
    set {_replacementPreset = newValue}
  }
  /// Returns true if `replacementPreset` has been explicitly set.
  var hasReplacementPreset: Bool {return self._replacementPreset != nil}
  /// Clears the value of `replacementPreset`. Subsequent reads from it will return its default value.
  mutating func clearReplacementPreset() {self._replacementPreset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _preset: TSP_Reference? = nil
  fileprivate var _replacementPreset: TSP_Reference? = nil
}

struct TSS_CommandPropertyEntryArchive: SwiftProtobuf.ExtensibleMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var property: UInt32 {
    get {return _property ?? 0}
    set {_property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return self._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {self._property = nil}

  var type: Int32 {
    get {return _type ?? 0}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var integerValue: Int32 {
    get {return _integerValue ?? 0}
    set {_integerValue = newValue}
  }
  /// Returns true if `integerValue` has been explicitly set.
  var hasIntegerValue: Bool {return self._integerValue != nil}
  /// Clears the value of `integerValue`. Subsequent reads from it will return its default value.
  mutating func clearIntegerValue() {self._integerValue = nil}

  var floatValue: Float {
    get {return _floatValue ?? 0}
    set {_floatValue = newValue}
  }
  /// Returns true if `floatValue` has been explicitly set.
  var hasFloatValue: Bool {return self._floatValue != nil}
  /// Clears the value of `floatValue`. Subsequent reads from it will return its default value.
  mutating func clearFloatValue() {self._floatValue = nil}

  var doubleValue: Double {
    get {return _doubleValue ?? 0}
    set {_doubleValue = newValue}
  }
  /// Returns true if `doubleValue` has been explicitly set.
  var hasDoubleValue: Bool {return self._doubleValue != nil}
  /// Clears the value of `doubleValue`. Subsequent reads from it will return its default value.
  mutating func clearDoubleValue() {self._doubleValue = nil}

  var stringValue: String {
    get {return _stringValue ?? String()}
    set {_stringValue = newValue}
  }
  /// Returns true if `stringValue` has been explicitly set.
  var hasStringValue: Bool {return self._stringValue != nil}
  /// Clears the value of `stringValue`. Subsequent reads from it will return its default value.
  mutating func clearStringValue() {self._stringValue = nil}

  var tspReference: TSP_Reference {
    get {return _tspReference ?? TSP_Reference()}
    set {_tspReference = newValue}
  }
  /// Returns true if `tspReference` has been explicitly set.
  var hasTspReference: Bool {return self._tspReference != nil}
  /// Clears the value of `tspReference`. Subsequent reads from it will return its default value.
  mutating func clearTspReference() {self._tspReference = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _property: UInt32? = nil
  fileprivate var _type: Int32? = nil
  fileprivate var _integerValue: Int32? = nil
  fileprivate var _floatValue: Float? = nil
  fileprivate var _doubleValue: Double? = nil
  fileprivate var _stringValue: String? = nil
  fileprivate var _tspReference: TSP_Reference? = nil
}

struct TSS_CommandPropertyMapArchive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var propertyEntries: [TSS_CommandPropertyEntryArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Extension support defined in TSSArchives.proto.

// MARK: - Extension Properties

// Swift Extensions on the exteneded Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

extension TSS_CommandPropertyEntryArchive {

  var TSS_color: TSP_Color {
    get {return getExtensionValue(ext: TSS_Extensions_color) ?? TSP_Color()}
    set {setExtensionValue(ext: TSS_Extensions_color, value: newValue)}
  }
  /// Returns true if extension `TSS_Extensions_color`
  /// has been explicitly set.
  var hasTSS_color: Bool {
    return hasExtensionValue(ext: TSS_Extensions_color)
  }
  /// Clears the value of extension `TSS_Extensions_color`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTSS_color() {
    clearExtensionValue(ext: TSS_Extensions_color)
  }

}

// MARK: - File's ExtensionMap: TSS_Tssarchives_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
let TSS_Tssarchives_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  TSS_Extensions_color
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

let TSS_Extensions_color = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TSP_Color>, TSS_CommandPropertyEntryArchive>(
  _protobuf_fieldNumber: 8,
  fieldName: "TSS.color"
)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TSS"

extension TSS_ValueType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ObjectType"),
    1: .same(proto: "IntType"),
    2: .same(proto: "FloatType"),
    3: .same(proto: "DoubleType"),
  ]
}

extension TSS_PropertyType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "InvalidPropertyType"),
    2: .same(proto: "NullPropertyType"),
    3: .same(proto: "IntegerPropertyType"),
    4: .same(proto: "FloatPropertyType"),
    5: .same(proto: "DoublePropertyType"),
    6: .same(proto: "NSStringPropertyType"),
    7: .same(proto: "TSPObjectPropertyType"),
  ]
}

extension TSS_StyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StyleArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "style_identifier"),
    3: .same(proto: "parent"),
    4: .standard(proto: "is_variation"),
    5: .same(proto: "stylesheet"),
  ]

  public var isInitialized: Bool {
    if let v = self._parent, !v.isInitialized {return false}
    if let v = self._stylesheet, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._name)
      case 2: try decoder.decodeSingularStringField(value: &self._styleIdentifier)
      case 3: try decoder.decodeSingularMessageField(value: &self._parent)
      case 4: try decoder.decodeSingularBoolField(value: &self._isVariation)
      case 5: try decoder.decodeSingularMessageField(value: &self._stylesheet)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._styleIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._parent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._isVariation {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if let v = self._stylesheet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSS_StyleArchive, rhs: TSS_StyleArchive) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._styleIdentifier != rhs._styleIdentifier {return false}
    if lhs._parent != rhs._parent {return false}
    if lhs._isVariation != rhs._isVariation {return false}
    if lhs._stylesheet != rhs._stylesheet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSS_StylesheetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StylesheetArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "styles"),
    2: .standard(proto: "identifier_to_style_map"),
    3: .same(proto: "parent"),
    4: .standard(proto: "is_locked"),
    5: .standard(proto: "parent_to_children_style_map"),
    6: .standard(proto: "can_cull_styles"),
    7: .standard(proto: "styles_for_10_0"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.styles) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.identifierToStyleMap) {return false}
    if let v = self._parent, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.parentToChildrenStyleMap) {return false}
    if let v = self._stylesFor100, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.styles)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.identifierToStyleMap)
      case 3: try decoder.decodeSingularMessageField(value: &self._parent)
      case 4: try decoder.decodeSingularBoolField(value: &self._isLocked)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.parentToChildrenStyleMap)
      case 6: try decoder.decodeSingularBoolField(value: &self._canCullStyles)
      case 7: try decoder.decodeSingularMessageField(value: &self._stylesFor100)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.styles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.styles, fieldNumber: 1)
    }
    if !self.identifierToStyleMap.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identifierToStyleMap, fieldNumber: 2)
    }
    if let v = self._parent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._isLocked {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if !self.parentToChildrenStyleMap.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parentToChildrenStyleMap, fieldNumber: 5)
    }
    if let v = self._canCullStyles {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }
    if let v = self._stylesFor100 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSS_StylesheetArchive, rhs: TSS_StylesheetArchive) -> Bool {
    if lhs.styles != rhs.styles {return false}
    if lhs.identifierToStyleMap != rhs.identifierToStyleMap {return false}
    if lhs._parent != rhs._parent {return false}
    if lhs._isLocked != rhs._isLocked {return false}
    if lhs.parentToChildrenStyleMap != rhs.parentToChildrenStyleMap {return false}
    if lhs._canCullStyles != rhs._canCullStyles {return false}
    if lhs._stylesFor100 != rhs._stylesFor100 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSS_StylesheetArchive.IdentifiedStyleEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSS_StylesheetArchive.protoMessageName + ".IdentifiedStyleEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .same(proto: "style"),
  ]

  public var isInitialized: Bool {
    if self._identifier == nil {return false}
    if self._style == nil {return false}
    if let v = self._style, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._identifier)
      case 2: try decoder.decodeSingularMessageField(value: &self._style)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._identifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._style {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSS_StylesheetArchive.IdentifiedStyleEntry, rhs: TSS_StylesheetArchive.IdentifiedStyleEntry) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs._style != rhs._style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSS_StylesheetArchive.StyleChildrenEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSS_StylesheetArchive.protoMessageName + ".StyleChildrenEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "children"),
  ]

  public var isInitialized: Bool {
    if self._parent == nil {return false}
    if let v = self._parent, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.children) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._parent)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.children)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._parent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.children.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.children, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSS_StylesheetArchive.StyleChildrenEntry, rhs: TSS_StylesheetArchive.StyleChildrenEntry) -> Bool {
    if lhs._parent != rhs._parent {return false}
    if lhs.children != rhs.children {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSS_StylesheetArchive.VersionedStyles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSS_StylesheetArchive.protoMessageName + ".VersionedStyles"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "styles"),
    2: .standard(proto: "identifier_to_style_map"),
    3: .standard(proto: "parent_to_children_style_map"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.styles) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.identifierToStyleMap) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.parentToChildrenStyleMap) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.styles)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.identifierToStyleMap)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.parentToChildrenStyleMap)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.styles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.styles, fieldNumber: 1)
    }
    if !self.identifierToStyleMap.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identifierToStyleMap, fieldNumber: 2)
    }
    if !self.parentToChildrenStyleMap.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parentToChildrenStyleMap, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSS_StylesheetArchive.VersionedStyles, rhs: TSS_StylesheetArchive.VersionedStyles) -> Bool {
    if lhs.styles != rhs.styles {return false}
    if lhs.identifierToStyleMap != rhs.identifierToStyleMap {return false}
    if lhs.parentToChildrenStyleMap != rhs.parentToChildrenStyleMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSS_ThemeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThemeArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "legacy_stylesheet"),
    3: .standard(proto: "theme_identifier"),
    4: .standard(proto: "document_stylesheet"),
    5: .standard(proto: "old_uuids_for_preset_replacements"),
    6: .standard(proto: "new_uuids_for_preset_replacements"),
    10: .standard(proto: "color_presets"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if let v = self._legacyStylesheet, !v.isInitialized {return false}
    if let v = self._documentStylesheet, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldUuidsForPresetReplacements) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.newUuidsForPresetReplacements) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.colorPresets) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._legacyStylesheet)
      case 3: try decoder.decodeSingularStringField(value: &self._themeIdentifier)
      case 4: try decoder.decodeSingularMessageField(value: &self._documentStylesheet)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.oldUuidsForPresetReplacements)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.newUuidsForPresetReplacements)
      case 10: try decoder.decodeRepeatedMessageField(value: &self.colorPresets)
      case 100..<536870912:
        try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TSS_ThemeArchive.self, fieldNumber: fieldNumber)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._legacyStylesheet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._themeIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._documentStylesheet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.oldUuidsForPresetReplacements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldUuidsForPresetReplacements, fieldNumber: 5)
    }
    if !self.newUuidsForPresetReplacements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.newUuidsForPresetReplacements, fieldNumber: 6)
    }
    if !self.colorPresets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.colorPresets, fieldNumber: 10)
    }
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 100, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSS_ThemeArchive, rhs: TSS_ThemeArchive) -> Bool {
    if lhs._legacyStylesheet != rhs._legacyStylesheet {return false}
    if lhs._themeIdentifier != rhs._themeIdentifier {return false}
    if lhs._documentStylesheet != rhs._documentStylesheet {return false}
    if lhs.oldUuidsForPresetReplacements != rhs.oldUuidsForPresetReplacements {return false}
    if lhs.newUuidsForPresetReplacements != rhs.newUuidsForPresetReplacements {return false}
    if lhs.colorPresets != rhs.colorPresets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TSS_ApplyThemeCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ApplyThemeCommandArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .same(proto: "commands"),
    3: .standard(proto: "old_theme"),
    4: .standard(proto: "new_theme"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.commands) {return false}
    if let v = self._oldTheme, !v.isInitialized {return false}
    if let v = self._newTheme, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.commands)
      case 3: try decoder.decodeSingularMessageField(value: &self._oldTheme)
      case 4: try decoder.decodeSingularMessageField(value: &self._newTheme)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.commands.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.commands, fieldNumber: 2)
    }
    if let v = self._oldTheme {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._newTheme {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSS_ApplyThemeCommandArchive, rhs: TSS_ApplyThemeCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.commands != rhs.commands {return false}
    if lhs._oldTheme != rhs._oldTheme {return false}
    if lhs._newTheme != rhs._newTheme {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSS_ApplyThemeChildCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ApplyThemeChildCommandArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .same(proto: "parent"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._parent, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._parent)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._parent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSS_ApplyThemeChildCommandArchive, rhs: TSS_ApplyThemeChildCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._parent != rhs._parent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSS_StyleUpdatePropertyMapCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StyleUpdatePropertyMapCommandArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .standard(proto: "current_style"),
    3: .standard(proto: "style_with_old_property_map"),
    4: .standard(proto: "style_with_new_property_map"),
    7: .standard(proto: "style_diff"),
    6: .standard(proto: "notify_for_style_clients"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._currentStyle == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._currentStyle, !v.isInitialized {return false}
    if let v = self._styleWithOldPropertyMap, !v.isInitialized {return false}
    if let v = self._styleWithNewPropertyMap, !v.isInitialized {return false}
    if let v = self._styleDiff, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._currentStyle)
      case 3: try decoder.decodeSingularMessageField(value: &self._styleWithOldPropertyMap)
      case 4: try decoder.decodeSingularMessageField(value: &self._styleWithNewPropertyMap)
      case 6: try decoder.decodeSingularBoolField(value: &self._notifyForStyleClients)
      case 7: try decoder.decodeSingularMessageField(value: &self._styleDiff)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._currentStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._styleWithOldPropertyMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._styleWithNewPropertyMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._notifyForStyleClients {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }
    if let v = self._styleDiff {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSS_StyleUpdatePropertyMapCommandArchive, rhs: TSS_StyleUpdatePropertyMapCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._currentStyle != rhs._currentStyle {return false}
    if lhs._styleWithOldPropertyMap != rhs._styleWithOldPropertyMap {return false}
    if lhs._styleWithNewPropertyMap != rhs._styleWithNewPropertyMap {return false}
    if lhs._styleDiff != rhs._styleDiff {return false}
    if lhs._notifyForStyleClients != rhs._notifyForStyleClients {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSS_ThemeReplacePresetCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThemeReplacePresetCommandArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    3: .same(proto: "preset"),
    4: .same(proto: "oldPreset"),
    5: .same(proto: "index"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._preset == nil {return false}
    if self._index == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._preset, !v.isInitialized {return false}
    if let v = self._oldPreset, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 3: try decoder.decodeSingularMessageField(value: &self._preset)
      case 4: try decoder.decodeSingularMessageField(value: &self._oldPreset)
      case 5: try decoder.decodeSingularUInt32Field(value: &self._index)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._preset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._oldPreset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._index {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSS_ThemeReplacePresetCommandArchive, rhs: TSS_ThemeReplacePresetCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._preset != rhs._preset {return false}
    if lhs._oldPreset != rhs._oldPreset {return false}
    if lhs._index != rhs._index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSS_ThemeReplaceColorPresetCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThemeReplaceColorPresetCommandArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .same(proto: "theme"),
    3: .same(proto: "color"),
    4: .standard(proto: "old_color"),
    5: .same(proto: "index"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._theme == nil {return false}
    if self._color == nil {return false}
    if self._oldColor == nil {return false}
    if self._index == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._theme, !v.isInitialized {return false}
    if let v = self._color, !v.isInitialized {return false}
    if let v = self._oldColor, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._theme)
      case 3: try decoder.decodeSingularMessageField(value: &self._color)
      case 4: try decoder.decodeSingularMessageField(value: &self._oldColor)
      case 5: try decoder.decodeSingularUInt32Field(value: &self._index)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._theme {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._oldColor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._index {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSS_ThemeReplaceColorPresetCommandArchive, rhs: TSS_ThemeReplaceColorPresetCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._theme != rhs._theme {return false}
    if lhs._color != rhs._color {return false}
    if lhs._oldColor != rhs._oldColor {return false}
    if lhs._index != rhs._index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSS_ThemeAddStylePresetCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThemeAddStylePresetCommandArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .same(proto: "theme"),
    3: .same(proto: "preset"),
    4: .standard(proto: "preset_kind"),
    5: .same(proto: "identifier"),
    6: .standard(proto: "add_preset_to_stylesheet"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._theme == nil {return false}
    if self._preset == nil {return false}
    if self._presetKind == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._theme, !v.isInitialized {return false}
    if let v = self._preset, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._theme)
      case 3: try decoder.decodeSingularMessageField(value: &self._preset)
      case 4: try decoder.decodeSingularStringField(value: &self._presetKind)
      case 5: try decoder.decodeSingularStringField(value: &self._identifier)
      case 6: try decoder.decodeSingularBoolField(value: &self._addPresetToStylesheet)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._theme {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._preset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._presetKind {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._identifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._addPresetToStylesheet {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSS_ThemeAddStylePresetCommandArchive, rhs: TSS_ThemeAddStylePresetCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._theme != rhs._theme {return false}
    if lhs._preset != rhs._preset {return false}
    if lhs._presetKind != rhs._presetKind {return false}
    if lhs._identifier != rhs._identifier {return false}
    if lhs._addPresetToStylesheet != rhs._addPresetToStylesheet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSS_ThemeRemoveStylePresetCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThemeRemoveStylePresetCommandArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .same(proto: "theme"),
    3: .same(proto: "preset"),
    4: .standard(proto: "preset_index"),
    5: .standard(proto: "preset_kind"),
    6: .same(proto: "identifier"),
    7: .standard(proto: "replacement_preset"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._theme == nil {return false}
    if self._preset == nil {return false}
    if self._presetIndex == nil {return false}
    if self._presetKind == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._theme, !v.isInitialized {return false}
    if let v = self._preset, !v.isInitialized {return false}
    if let v = self._replacementPreset, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._theme)
      case 3: try decoder.decodeSingularMessageField(value: &self._preset)
      case 4: try decoder.decodeSingularUInt32Field(value: &self._presetIndex)
      case 5: try decoder.decodeSingularStringField(value: &self._presetKind)
      case 6: try decoder.decodeSingularStringField(value: &self._identifier)
      case 7: try decoder.decodeSingularMessageField(value: &self._replacementPreset)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._theme {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._preset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._presetIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._presetKind {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._identifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._replacementPreset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSS_ThemeRemoveStylePresetCommandArchive, rhs: TSS_ThemeRemoveStylePresetCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._theme != rhs._theme {return false}
    if lhs._preset != rhs._preset {return false}
    if lhs._presetIndex != rhs._presetIndex {return false}
    if lhs._presetKind != rhs._presetKind {return false}
    if lhs._identifier != rhs._identifier {return false}
    if lhs._replacementPreset != rhs._replacementPreset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSS_ThemeMovePresetCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThemeMovePresetCommandArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .same(proto: "theme"),
    3: .standard(proto: "preset_id"),
    4: .standard(proto: "new_index"),
    5: .standard(proto: "old_index"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._theme == nil {return false}
    if self._presetID == nil {return false}
    if self._newIndex == nil {return false}
    if self._oldIndex == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._theme, !v.isInitialized {return false}
    if let v = self._presetID, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._theme)
      case 3: try decoder.decodeSingularMessageField(value: &self._presetID)
      case 4: try decoder.decodeSingularUInt32Field(value: &self._newIndex)
      case 5: try decoder.decodeSingularUInt32Field(value: &self._oldIndex)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._theme {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._presetID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._newIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._oldIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSS_ThemeMovePresetCommandArchive, rhs: TSS_ThemeMovePresetCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._theme != rhs._theme {return false}
    if lhs._presetID != rhs._presetID {return false}
    if lhs._newIndex != rhs._newIndex {return false}
    if lhs._oldIndex != rhs._oldIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSS_ThemeReplaceStylePresetAndDisconnectStylesCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThemeReplaceStylePresetAndDisconnectStylesCommandArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
    2: .same(proto: "preset"),
    3: .standard(proto: "replacement_preset"),
  ]

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._preset == nil {return false}
    if self._replacementPreset == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._preset, !v.isInitialized {return false}
    if let v = self._replacementPreset, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._super)
      case 2: try decoder.decodeSingularMessageField(value: &self._preset)
      case 3: try decoder.decodeSingularMessageField(value: &self._replacementPreset)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._preset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._replacementPreset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSS_ThemeReplaceStylePresetAndDisconnectStylesCommandArchive, rhs: TSS_ThemeReplaceStylePresetAndDisconnectStylesCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._preset != rhs._preset {return false}
    if lhs._replacementPreset != rhs._replacementPreset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSS_CommandPropertyEntryArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandPropertyEntryArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "property"),
    2: .same(proto: "type"),
    3: .standard(proto: "integer_value"),
    4: .standard(proto: "float_value"),
    5: .standard(proto: "double_value"),
    6: .standard(proto: "string_value"),
    7: .standard(proto: "tsp_reference"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if self._property == nil {return false}
    if self._type == nil {return false}
    if let v = self._tspReference, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._property)
      case 2: try decoder.decodeSingularInt32Field(value: &self._type)
      case 3: try decoder.decodeSingularInt32Field(value: &self._integerValue)
      case 4: try decoder.decodeSingularFloatField(value: &self._floatValue)
      case 5: try decoder.decodeSingularDoubleField(value: &self._doubleValue)
      case 6: try decoder.decodeSingularStringField(value: &self._stringValue)
      case 7: try decoder.decodeSingularMessageField(value: &self._tspReference)
      case 8..<2001:
        try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TSS_CommandPropertyEntryArchive.self, fieldNumber: fieldNumber)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._property {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._type {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._integerValue {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._floatValue {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    }
    if let v = self._doubleValue {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    }
    if let v = self._stringValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._tspReference {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 8, end: 2001)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSS_CommandPropertyEntryArchive, rhs: TSS_CommandPropertyEntryArchive) -> Bool {
    if lhs._property != rhs._property {return false}
    if lhs._type != rhs._type {return false}
    if lhs._integerValue != rhs._integerValue {return false}
    if lhs._floatValue != rhs._floatValue {return false}
    if lhs._doubleValue != rhs._doubleValue {return false}
    if lhs._stringValue != rhs._stringValue {return false}
    if lhs._tspReference != rhs._tspReference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TSS_CommandPropertyMapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandPropertyMapArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "property_entries"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.propertyEntries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.propertyEntries)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.propertyEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.propertyEntries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSS_CommandPropertyMapArchive, rhs: TSS_CommandPropertyMapArchive) -> Bool {
    if lhs.propertyEntries != rhs.propertyEntries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
